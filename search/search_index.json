{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"About","text":""},{"location":"index.html#lineflow","title":"LineFlow","text":"<p>Welcome to the LineFlow documentation! LineFlow is an extensible, open-source Python framework for simulating production lines of arbitrary complexity and also offers the ability to train agents via reinforcement learning to control them.</p>    Sorry, your browser can\u2019t play this video.  <p>Install with</p> <pre><code>pip install lineflow-rl\n</code></pre> <p>If you use our work in your research, please consider citing us with</p> <pre><code>@misc{m\u00fcller2025lineflowframeworklearnactive,\n      title={LineFlow: A Framework to Learn Active Control of Production Lines}, \n      author={Kai M\u00fcller and Martin Wenzel and Tobias Windisch},\n      year={2025},\n      eprint={2505.06744},\n      archivePrefix={arXiv},\n      primaryClass={cs.LG},\n      url={https://arxiv.org/abs/2505.06744}, \n}\n</code></pre>"},{"location":"index.html#authors","title":"Authors","text":"<ul> <li>Kai M\u00fcller (University of Applied Sciences, Kempten)</li> <li>Tobias Windisch (University of Applied Sciences, Kempten)</li> <li>Martin Wenzel (University of Applied Sciences, Kempten)</li> </ul>"},{"location":"index.html#funding","title":"Funding","text":"<p>The research behind LineFlow is funded by the Bavarian state ministry of research. Learn more here.</p>"},{"location":"api.html","title":"States","text":""},{"location":"api.html#lineflow.simulation.states.BaseState","title":"<code>BaseState</code>","text":"<p>Abstract base class for states.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the state</p> required <code>is_actionable</code> <code>bool</code> <p>If <code>True</code>, state can be changed by a policy</p> <code>False</code> <code>is_observable</code> <code>bool</code> <p>If <code>True</code>, state can be observed by a policy</p> <code>True</code> <code>exception_on_nan</code> <code>bool</code> <p>If <code>True</code> an exception is raised whenever an instance tries to access the value of the state and this value is <code>None</code>.</p> <code>False</code> Source code in <code>lineflow/simulation/states.py</code> <pre><code>class BaseState(metaclass=ABCMeta):\n    \"\"\"\n    Abstract base class for states.\n\n    Args:\n        name (str): Name of the state\n        is_actionable (bool): If `True`, state can be changed by a policy\n        is_observable (bool): If `True`, state can be observed by a policy\n        exception_on_nan (bool): If `True` an exception is raised whenever an instance tries to\n            access the value of the state and this value is `None`.\n    \"\"\"\n\n    def __init__(self, name, is_actionable=False, is_observable=True, exception_on_nan=False):\n        self.name = name\n        self.is_actionable = is_actionable\n        self.is_observable = is_observable\n        self._value = None\n        self.exception_on_nan = exception_on_nan\n\n    @property\n    def value(self):\n        \"\"\"\n        The (scalar) value of the state.\n        \"\"\"\n        if self._value is None and self.exception_on_nan:\n            raise ValueError('NAN value detected')\n        return self._value\n\n    def _change_value(self, value):\n        \"\"\"\n        Method that has to be called whenever the value of the state should be changed.\n        \"\"\"\n        self.assert_valid(value)\n        self._value = value\n\n    def apply(self, value):\n        \"\"\"\n        Should be called from a policy to change the value of the state\n        \"\"\"\n        assert self.is_actionable, 'Trying to set a non-action'\n        self._change_value(value)\n\n    def update(self, value):\n        \"\"\"\n        Should be called from a `lineflow.simulation.base.LineObject` to change the value\n        of the state\n        \"\"\"\n        self._change_value(value)\n\n    def to_str(self):\n        return str(self.value)\n\n    def print(self):\n        return self.to_str()\n\n    def reverse(self, series):\n        \"\"\"\n        To be implemented for states that hold categorical values\n        \"\"\"\n        return series\n\n    def assert_valid(self, value):\n        \"\"\"\n        Can be implemented by a downstream class to check whether value to be set is valid\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api.html#lineflow.simulation.states.BaseState.value","title":"<code>value</code>  <code>property</code>","text":"<p>The (scalar) value of the state.</p>"},{"location":"api.html#lineflow.simulation.states.BaseState.apply","title":"<code>apply(value)</code>","text":"<p>Should be called from a policy to change the value of the state</p> Source code in <code>lineflow/simulation/states.py</code> <pre><code>def apply(self, value):\n    \"\"\"\n    Should be called from a policy to change the value of the state\n    \"\"\"\n    assert self.is_actionable, 'Trying to set a non-action'\n    self._change_value(value)\n</code></pre>"},{"location":"api.html#lineflow.simulation.states.BaseState.assert_valid","title":"<code>assert_valid(value)</code>","text":"<p>Can be implemented by a downstream class to check whether value to be set is valid</p> Source code in <code>lineflow/simulation/states.py</code> <pre><code>def assert_valid(self, value):\n    \"\"\"\n    Can be implemented by a downstream class to check whether value to be set is valid\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api.html#lineflow.simulation.states.BaseState.reverse","title":"<code>reverse(series)</code>","text":"<p>To be implemented for states that hold categorical values</p> Source code in <code>lineflow/simulation/states.py</code> <pre><code>def reverse(self, series):\n    \"\"\"\n    To be implemented for states that hold categorical values\n    \"\"\"\n    return series\n</code></pre>"},{"location":"api.html#lineflow.simulation.states.BaseState.update","title":"<code>update(value)</code>","text":"<p>Should be called from a <code>lineflow.simulation.base.LineObject</code> to change the value of the state</p> Source code in <code>lineflow/simulation/states.py</code> <pre><code>def update(self, value):\n    \"\"\"\n    Should be called from a `lineflow.simulation.base.LineObject` to change the value\n    of the state\n    \"\"\"\n    self._change_value(value)\n</code></pre>"},{"location":"api.html#lineflow.simulation.states.CountState","title":"<code>CountState</code>","text":"<p>               Bases: <code>NumericState</code></p> <p>State to count discrete events.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the state</p> required <code>vmin</code> <code>float</code> <p>The allowed minimal value the state accepts</p> <code>0</code> <code>vmax</code> <code>float</code> <p>The allowed maximal value the state accepts</p> <code>inf</code> <code>is_actionable</code> <code>bool</code> <p>If <code>True</code>, state can be changed by a policy</p> <code>False</code> <code>is_observable</code> <code>bool</code> <p>If <code>True</code>, state can be observed by a policy</p> <code>True</code> <code>exception_on_nan</code> <code>bool</code> <p>If <code>True</code> an exception is raised whenever an instance tries to access the value of the state and this value is <code>None</code>.</p> <code>False</code> Source code in <code>lineflow/simulation/states.py</code> <pre><code>class CountState(NumericState):\n    \"\"\"\n    State to count discrete events.\n\n    Args:\n        name (str): Name of the state\n        vmin (float): The allowed minimal value the state accepts\n        vmax (float): The allowed maximal value the state accepts\n        is_actionable (bool): If `True`, state can be changed by a policy\n        is_observable (bool): If `True`, state can be observed by a policy\n        exception_on_nan (bool): If `True` an exception is raised whenever an instance tries to\n            access the value of the state and this value is `None`.\n    \"\"\"\n    def __init__(\n        self,\n        name,\n        vmin=0,\n        vmax=np.inf,\n        is_actionable=False,\n        is_observable=True,\n        exception_on_nan=False,\n    ):\n        super().__init__(\n            name=name,\n            is_actionable=is_actionable,\n            is_observable=is_observable,\n            vmin=vmin,\n            vmax=vmax,\n            exception_on_nan=exception_on_nan,\n        )\n\n    def assert_valid(self, value):\n        NumericState.assert_valid(self, value)\n        assert int(value) == value, f\"Value {value} is not integer\"\n</code></pre>"},{"location":"api.html#lineflow.simulation.states.Data","title":"<code>Data</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>lineflow/simulation/states.py</code> <pre><code>class Data(object):\n    def __init__(self, feature_names, observables=None):\n        self.feature_names = feature_names\n\n        if observables is None:\n            # All features are observable\n            observables = (len(self.feature_names))*[True]\n        self.observables = np.array(observables)\n\n        self.T = np.array([])\n        self.X = np.array([]).reshape(0, len(feature_names))\n\n        self.modes = []\n        for feature in self.feature_names:\n            if feature.endswith('mode'):\n                self.modes.append(True)\n            else:\n                self.modes.append(False)\n\n    def append(self, end_time, values):\n        self.T = np.append(self.T, end_time)\n        self.X = np.vstack([self.X, values])\n\n    def get_modes(self, lookback=None):\n        \"\"\"\n        Returns the percent of working mode of the cells of a line over the\n        lookback period\n        \"\"\"\n        if lookback is None:\n            lookback = self.T.shape[0]\n\n        return self.X[-lookback:, self.modes]\n\n    def get_uptime(self, lookback=None):\n        \"\"\"\n        Returns the percentage of the station being in working mode\n        (mode=0) over the lookback period\n        \"\"\"\n        modes = self.get_modes(lookback=lookback)\n        uptimes = (modes == 0).mean(axis=0)\n        return uptimes\n\n    def get_observations(self, lookback=None, include_time=True):\n        \"\"\"\n        Here, only observable values are returned\n        \"\"\"\n        if lookback is None:\n            lookback = self.T.shape[0]\n\n        X = self.X[-lookback:, self.observables]\n\n        if include_time:\n            T = self.T[-lookback:].reshape(-1, 1)\n            T = T - T.max()\n            return np.hstack([X, T])\n        else:\n            return X\n\n    def df(self):\n        df = pd.DataFrame(\n            data=self.X,\n            columns=self.feature_names,\n        )\n        df['T_end'] = self.T\n        return df\n</code></pre>"},{"location":"api.html#lineflow.simulation.states.Data.get_modes","title":"<code>get_modes(lookback=None)</code>","text":"<p>Returns the percent of working mode of the cells of a line over the lookback period</p> Source code in <code>lineflow/simulation/states.py</code> <pre><code>def get_modes(self, lookback=None):\n    \"\"\"\n    Returns the percent of working mode of the cells of a line over the\n    lookback period\n    \"\"\"\n    if lookback is None:\n        lookback = self.T.shape[0]\n\n    return self.X[-lookback:, self.modes]\n</code></pre>"},{"location":"api.html#lineflow.simulation.states.Data.get_observations","title":"<code>get_observations(lookback=None, include_time=True)</code>","text":"<p>Here, only observable values are returned</p> Source code in <code>lineflow/simulation/states.py</code> <pre><code>def get_observations(self, lookback=None, include_time=True):\n    \"\"\"\n    Here, only observable values are returned\n    \"\"\"\n    if lookback is None:\n        lookback = self.T.shape[0]\n\n    X = self.X[-lookback:, self.observables]\n\n    if include_time:\n        T = self.T[-lookback:].reshape(-1, 1)\n        T = T - T.max()\n        return np.hstack([X, T])\n    else:\n        return X\n</code></pre>"},{"location":"api.html#lineflow.simulation.states.Data.get_uptime","title":"<code>get_uptime(lookback=None)</code>","text":"<p>Returns the percentage of the station being in working mode (mode=0) over the lookback period</p> Source code in <code>lineflow/simulation/states.py</code> <pre><code>def get_uptime(self, lookback=None):\n    \"\"\"\n    Returns the percentage of the station being in working mode\n    (mode=0) over the lookback period\n    \"\"\"\n    modes = self.get_modes(lookback=lookback)\n    uptimes = (modes == 0).mean(axis=0)\n    return uptimes\n</code></pre>"},{"location":"api.html#lineflow.simulation.states.DiscreteState","title":"<code>DiscreteState</code>","text":"<p>               Bases: <code>BaseState</code></p> <p>State to handle discrete states, like integer numbers or categories.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the state</p> required <code>categories</code> <code>list</code> <p>List of values this state can take.</p> required <code>is_actionable</code> <code>bool</code> <p>If <code>True</code>, state can be changed by a policy</p> <code>False</code> <code>is_observable</code> <code>bool</code> <p>If <code>True</code>, state can be observed by a policy</p> <code>True</code> <code>exception_on_nan</code> <code>bool</code> <p>If <code>True</code> an exception is raised whenever an instance tries to access the value of the state and this value is <code>None</code>.</p> <code>False</code> Source code in <code>lineflow/simulation/states.py</code> <pre><code>class DiscreteState(BaseState):\n    \"\"\"\n    State to handle discrete states, like integer numbers or categories.\n\n    Args:\n        name (str): Name of the state\n        categories (list): List of values this state can take.\n        is_actionable (bool): If `True`, state can be changed by a policy\n        is_observable (bool): If `True`, state can be observed by a policy\n        exception_on_nan (bool): If `True` an exception is raised whenever an instance tries to\n            access the value of the state and this value is `None`.\n    \"\"\"\n\n    def __init__(\n        self,\n        name,\n        categories,\n        is_actionable=False,\n        is_observable=True,\n        exception_on_nan=False,\n    ):\n        super().__init__(\n            name=name,\n            is_actionable=is_actionable,\n            is_observable=is_observable,\n            exception_on_nan=exception_on_nan,\n        )\n        self.categories = categories\n        self.n_categories = len(self.categories)\n        self.values = np.arange(self.n_categories)\n\n        self._mapping = dict(zip(self.categories, self.values))\n\n    def update(self, value):\n        mapped_value = self._mapping[value]\n        self._change_value(mapped_value)\n\n    def to_str(self):\n        return self.categories[self.value]\n\n    def reverse(self, series):\n        return series.astype(int).apply(lambda i: self.categories[i])\n\n    def assert_valid(self, value):\n        assert not isinstance(value, bool), f\"{value} should not be boolean, but one of {self.values}\"\n        assert value in self.values, f\"{value}, not in {self.values}\"\n\n    def set_next(self):\n        self._change_value((self.value+1) % self.n_categories)\n</code></pre>"},{"location":"api.html#lineflow.simulation.states.LineStates","title":"<code>LineStates</code>","text":"<p>               Bases: <code>object</code></p> <p>Bag of all ObjectStates of all <code>LineObjects</code>s of a line.</p> <p>Parameters:</p> Name Type Description Default <code>objects</code> <code>dict</code> <p>Dict where keys are the object name and the value are of type <code>ObjectStates</code>.</p> required Source code in <code>lineflow/simulation/states.py</code> <pre><code>class LineStates(object):\n    \"\"\"\n    Bag of all ObjectStates of all [`LineObjects`][lineflow.simulation.states.LineStates]s of a line.\n\n    Args:\n        objects (dict): Dict where keys are the object name and the value are of type\n            [`ObjectStates`][lineflow.simulation.states.ObjectStates].\n    \"\"\"\n\n    def __init__(self, objects: dict, env):\n        self.objects = objects\n        self.env = env\n\n        # Fix an ordering of the objects\n        self.object_names = [\n            name for name in self.objects.keys()\n        ]\n\n        # Fix an order of the features\n        self.feature_names = []\n        self.observables = []\n        self.actionables = []\n        for name in self.object_names:\n            self.feature_names.extend(self.objects[name]._get_names_with_prefix(name))\n            self.observables.extend(self.objects[name].observables)\n            self.actionables.extend(self.objects[name].actionables)\n\n        self.data = Data(\n            feature_names=self.feature_names,\n            observables=self.observables)\n\n    @property\n    def observable_features(self):\n        return [f for f, o in zip(self.feature_names, self.observables) if o]\n\n    @property\n    def actionable_features(self):\n        return [f for f, a in zip(self.feature_names, self.actionables) if a]\n\n    def get_actions(self):\n        \"\"\"\n        Returns a list of actions for policies to design valid outputs\n        \"\"\"\n        actions = {}\n\n        for object_name in self.object_names:\n\n            object_states = []\n            for state_name in self[object_name].names:\n                state = self[object_name][state_name]\n                if state.is_actionable:\n                    object_states.append(state)\n\n            if len(object_states) &gt; 0:\n                actions[object_name] = object_states\n        return actions\n\n    def __getitem__(self, name):\n        return self.objects[name]\n\n    def apply(self, values):\n        for object_name, object_values in values.items():\n            self[object_name].apply(object_values)\n\n    def update(self, values):\n        for object_name, object_values in values.items():\n            self[object_name].update(object_values)\n\n    @property\n    def values(self):\n        data = np.array([], dtype=np.float32)\n        for name in self.object_names:\n            data = np.append(data, self.objects[name].values)\n        return data\n\n    def log(self):\n        \"\"\"\n        Appends the (current) values of all objects to the data class\n        \"\"\"\n\n        self.data.append(\n            end_time=self.env.now,\n            values=self.values\n        )\n\n    def get_observations(self, lookback=None, include_time=True):\n        return self.data.get_observations(lookback=lookback, include_time=include_time)\n\n    def get_n_parts_produced(self):\n        return int(sum(\n            [v for f, v in self.to_dict().items() if f.endswith('n_parts_produced')]\n        ))\n\n    def get_n_scrap_parts(self):\n        return int(sum(\n            [v for f, v in self.to_dict().items() if f.endswith('n_scrap_parts')]\n        ))\n\n    def get_uptime(self, lookback=None):\n        return self.data.get_uptime(lookback=lookback)\n\n    def to_dict(self):\n        return dict(zip(self.feature_names, self.values))\n\n    def __iter__(self):\n        for object_name in self.object_names:\n            for state_name in self[object_name].names:\n                yield object_name, state_name\n\n    def df(self, reverse=True, lookback=None):\n        \"\"\"\n        This function is expensive in time and should only be called after simulation is finished\n        \"\"\"\n        df = self.data.df()\n\n        if lookback is not None:\n            df = df.iloc[-lookback:]\n\n        if reverse:\n            for object_name, state_name in self:\n                state = self[object_name][state_name]\n                feature = f\"{object_name}_{state_name}\"\n                if isinstance(state, DiscreteState) or isinstance(state, TokenState):\n                    df[feature] = state.reverse(df[feature])\n\n        df['T_start'] = df['T_end'].shift(1).fillna(0.0)\n        return df\n</code></pre>"},{"location":"api.html#lineflow.simulation.states.LineStates.df","title":"<code>df(reverse=True, lookback=None)</code>","text":"<p>This function is expensive in time and should only be called after simulation is finished</p> Source code in <code>lineflow/simulation/states.py</code> <pre><code>def df(self, reverse=True, lookback=None):\n    \"\"\"\n    This function is expensive in time and should only be called after simulation is finished\n    \"\"\"\n    df = self.data.df()\n\n    if lookback is not None:\n        df = df.iloc[-lookback:]\n\n    if reverse:\n        for object_name, state_name in self:\n            state = self[object_name][state_name]\n            feature = f\"{object_name}_{state_name}\"\n            if isinstance(state, DiscreteState) or isinstance(state, TokenState):\n                df[feature] = state.reverse(df[feature])\n\n    df['T_start'] = df['T_end'].shift(1).fillna(0.0)\n    return df\n</code></pre>"},{"location":"api.html#lineflow.simulation.states.LineStates.get_actions","title":"<code>get_actions()</code>","text":"<p>Returns a list of actions for policies to design valid outputs</p> Source code in <code>lineflow/simulation/states.py</code> <pre><code>def get_actions(self):\n    \"\"\"\n    Returns a list of actions for policies to design valid outputs\n    \"\"\"\n    actions = {}\n\n    for object_name in self.object_names:\n\n        object_states = []\n        for state_name in self[object_name].names:\n            state = self[object_name][state_name]\n            if state.is_actionable:\n                object_states.append(state)\n\n        if len(object_states) &gt; 0:\n            actions[object_name] = object_states\n    return actions\n</code></pre>"},{"location":"api.html#lineflow.simulation.states.LineStates.log","title":"<code>log()</code>","text":"<p>Appends the (current) values of all objects to the data class</p> Source code in <code>lineflow/simulation/states.py</code> <pre><code>def log(self):\n    \"\"\"\n    Appends the (current) values of all objects to the data class\n    \"\"\"\n\n    self.data.append(\n        end_time=self.env.now,\n        values=self.values\n    )\n</code></pre>"},{"location":"api.html#lineflow.simulation.states.NumericState","title":"<code>NumericState</code>","text":"<p>               Bases: <code>BaseState</code></p> <p>State to handle numeric values.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the state</p> required <code>vmin</code> <code>float</code> <p>The allowed minimal value the state accepts</p> <code>-inf</code> <code>vmax</code> <code>float</code> <p>The allowed maximal value the state accepts</p> <code>inf</code> <code>is_actionable</code> <code>bool</code> <p>If <code>True</code>, state can be changed by a policy</p> <code>False</code> <code>is_observable</code> <code>bool</code> <p>If <code>True</code>, state can be observed by a policy</p> <code>True</code> <code>exception_on_nan</code> <code>bool</code> <p>If <code>True</code> an exception is raised whenever an instance tries to access the value of the state and this value is <code>None</code>.</p> <code>False</code> Source code in <code>lineflow/simulation/states.py</code> <pre><code>class NumericState(BaseState):\n    \"\"\"\n    State to handle numeric values.\n\n    Args:\n        name (str): Name of the state\n        vmin (float): The allowed minimal value the state accepts\n        vmax (float): The allowed maximal value the state accepts\n        is_actionable (bool): If `True`, state can be changed by a policy\n        is_observable (bool): If `True`, state can be observed by a policy\n        exception_on_nan (bool): If `True` an exception is raised whenever an instance tries to\n            access the value of the state and this value is `None`.\n    \"\"\"\n    def __init__(\n        self,\n        name,\n        vmin=-np.inf,\n        vmax=np.inf,\n        is_actionable=False,\n        is_observable=True,\n        exception_on_nan=False,\n    ):\n        super().__init__(\n            name=name,\n            is_actionable=is_actionable,\n            is_observable=is_observable,\n            exception_on_nan=exception_on_nan,\n        )\n        self.vmin = vmin\n        self.vmax = vmax\n\n    def assert_valid(self, value):\n        assert (\n            (self.vmin &lt;= value) and\n            (value &lt;= self.vmax)\n        ), f'Violated: {self.vmin}&lt;={value}&lt;={self.vmax}'\n\n    def increment(self):\n        \"\"\"\n        Increments the value by 1\n        \"\"\"\n        self._change_value(self.value+1)\n\n    def decrement(self):\n        \"\"\"\n        Decrements the value by 1\n        \"\"\"\n        self._change_value(self.value-1)\n</code></pre>"},{"location":"api.html#lineflow.simulation.states.NumericState.decrement","title":"<code>decrement()</code>","text":"<p>Decrements the value by 1</p> Source code in <code>lineflow/simulation/states.py</code> <pre><code>def decrement(self):\n    \"\"\"\n    Decrements the value by 1\n    \"\"\"\n    self._change_value(self.value-1)\n</code></pre>"},{"location":"api.html#lineflow.simulation.states.NumericState.increment","title":"<code>increment()</code>","text":"<p>Increments the value by 1</p> Source code in <code>lineflow/simulation/states.py</code> <pre><code>def increment(self):\n    \"\"\"\n    Increments the value by 1\n    \"\"\"\n    self._change_value(self.value+1)\n</code></pre>"},{"location":"api.html#lineflow.simulation.states.ObjectStates","title":"<code>ObjectStates</code>","text":"<p>               Bases: <code>object</code></p> <p>Bag of all states of a LineObject</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>list</code> <p>List of <code>BaseState</code> objects.</p> <code>()</code> Source code in <code>lineflow/simulation/states.py</code> <pre><code>class ObjectStates(object):\n    \"\"\"\n    Bag of all states of a LineObject\n\n    Args:\n        states (list): List of [`BaseState`][lineflow.simulation.states.BaseState] objects.\n    \"\"\"\n\n    def __init__(self, *states):\n        self.names = [s.name for s in states]\n        self.states = {\n            state.name: state for state in states\n        }\n\n        self.observables = [self.states[n].is_observable for n in self.names]\n        self.actionables = [self.states[n].is_actionable for n in self.names]\n\n    def apply(self, values):\n        \"\"\"\n        Applies the values to all states\n\n        Args:\n            values (dict): Dict where the keys are the names of the internal states and the values\n                are the values to be applied.\n        \"\"\"\n        for name, value in values.items():\n            self[name].apply(value)\n\n    def update(self, values):\n        \"\"\"\n        Updates the values of all states\n\n        Args:\n            values (dict): Dict where the keys are the names of the internal states and the values\n                are the values to be updated.\n        \"\"\"\n        # TODO: Ugly code duplicate\n        for name, value in values.items():\n            self[name].update(value)\n\n    @property\n    def values(self):\n        return np.array([self.states[n].value for n in self.names])\n\n    def __getitem__(self, name):\n        return self.states[name]\n\n    def _get_names_with_prefix(self, prefix=None):\n        prefix = \"\" if prefix is None else f\"{prefix}_\"\n        return [f\"{prefix}{n}\" for n in self.names]\n\n    def to_dict(self, prefix=None):\n        return dict(\n            zip(\n                self._get_names_with_prefix(prefix),\n                self.values\n            )\n        )\n</code></pre>"},{"location":"api.html#lineflow.simulation.states.ObjectStates.apply","title":"<code>apply(values)</code>","text":"<p>Applies the values to all states</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>dict</code> <p>Dict where the keys are the names of the internal states and the values are the values to be applied.</p> required Source code in <code>lineflow/simulation/states.py</code> <pre><code>def apply(self, values):\n    \"\"\"\n    Applies the values to all states\n\n    Args:\n        values (dict): Dict where the keys are the names of the internal states and the values\n            are the values to be applied.\n    \"\"\"\n    for name, value in values.items():\n        self[name].apply(value)\n</code></pre>"},{"location":"api.html#lineflow.simulation.states.ObjectStates.update","title":"<code>update(values)</code>","text":"<p>Updates the values of all states</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>dict</code> <p>Dict where the keys are the names of the internal states and the values are the values to be updated.</p> required Source code in <code>lineflow/simulation/states.py</code> <pre><code>def update(self, values):\n    \"\"\"\n    Updates the values of all states\n\n    Args:\n        values (dict): Dict where the keys are the names of the internal states and the values\n            are the values to be updated.\n    \"\"\"\n    # TODO: Ugly code duplicate\n    for name, value in values.items():\n        self[name].update(value)\n</code></pre>"},{"location":"api.html#lineflow.simulation.states.TokenState","title":"<code>TokenState</code>","text":"<p>               Bases: <code>BaseState</code></p> <p>State to handle discrete objects where its not clear from the begining which and how many objects need to be tracked.</p> Source code in <code>lineflow/simulation/states.py</code> <pre><code>class TokenState(BaseState):\n    \"\"\"\n    State to handle discrete objects where its not clear from the begining which and how many\n    objects need to be tracked.\n    \"\"\"\n    def __init__(self, name, mapping=None, is_actionable=False, is_observable=False):\n        super().__init__(name=name, is_actionable=is_actionable, is_observable=is_observable)\n\n        if mapping is None:\n            self._mapping = {}\n        else:\n            self._mapping = mapping\n        self.tokens = []\n\n    def _get_next_value(self):\n\n        if len(self._mapping.values()) == 0:\n            return 0\n        else:\n            return max(self._mapping.values())+1\n\n    def assert_valid(self, value):\n        assert value in self._mapping.values()\n\n    def update(self, token):\n        if token not in self._mapping:\n            # Generate new id for this token\n            self._mapping[token] = self._get_next_value()\n            self.tokens.append(token)\n\n        value = self._mapping[token]\n        self._change_value(value)\n\n    def reverse(self, series):\n        return series.astype(int).apply(lambda i: self.tokens[i])\n</code></pre>"},{"location":"api.html#simulation","title":"Simulation","text":"<p>This file is a wrapper around our simulation such that it is compatible with the stable-baselines repo</p>"},{"location":"api.html#lineflow.simulation.line.Line","title":"<code>Line</code>","text":"<p>Parameters:</p> Name Type Description Default <code>realtime</code> <code>bool</code> <p>Only if <code>visualize</code> is <code>True</code></p> <code>False</code> <code>factor</code> <code>float</code> <p>visualization speed</p> <code>0.5</code> <code>info</code> <code>list</code> <p>A list of line data that is retrivable over the get_info() method. That is <code>info = [(\"A1\", n_workers), (\"A3\", \"assembly_time\")]</code>. Data will be logged in experiments.</p> <code>None</code> Source code in <code>lineflow/simulation/line.py</code> <pre><code>class Line:\n    \"\"\"\n    Args:\n        realtime (bool): Only if `visualize` is `True`\n        factor (float): visualization speed\n        info (list): A list of line data that is retrivable over the get_info() method.\n            That is `info = [(\"A1\", n_workers), (\"A3\", \"assembly_time\")]`.\n            Data will be logged in experiments.\n    \"\"\"\n\n    def __init__(\n        self,\n        realtime=False,\n        factor=0.5,\n        random_state=10,\n        step_size=1,\n        scrap_factor=1,\n        info=None,\n    ):\n\n        # TODO: This attribute needs to be refactored in future as it is only used by the\n        # gym-simulation\n        self.scrap_factor = scrap_factor\n        self.realtime = realtime\n        self.factor = factor\n        self.step_size = step_size\n        if info is None:\n            info = []\n        self._info = info\n\n        self.reset(random_state=random_state)\n\n    @property\n    def name(self):\n        return self.__class__.__name__\n\n    def info(self):\n        \"\"\"\n        Returns additional Information about the line\n        \"\"\"\n        general = {\n            \"name\": self.name,\n            \"T\": self.env.now,\n            \"n_parts\": self.get_n_parts_produced(),\n            \"n_scrap_parts\": self.get_n_scrap_parts(),\n        }\n\n        additional = {\n            f\"{station}_{attribute}\": self.state.objects[station].states[attribute].value\n            for station, attribute in self._info\n        }\n        return {**general, **additional}\n\n    def _make_env(self):\n        if self.realtime:\n            self.env = simpy.rt.RealtimeEnvironment(factor=self.factor, strict=False)\n        else:\n            self.env = simpy.Environment()\n\n    def _make_objects(self):\n        \"\"\"\n        Builds the LineObjects\n        \"\"\"\n        # Build the stations and connectors\n        with StationaryObject() as objects:\n            self.build()\n\n        self._objects = {}\n\n        for obj in objects:\n            if obj.name in self._objects:\n                raise ValueError(f'Multiple objects with name {obj.name} exist')\n            self._objects[obj.name] = obj\n\n        # Validate carrier specs\n        for obj in self._objects.values():\n            if hasattr(obj, 'carrier_specs'):\n                self._validate_carrier_specs(obj.carrier_specs)\n\n    def _validate_carrier_specs(self, specs):\n        for carrier_name, part_specs in specs.items():\n            for part_name, part_spec in part_specs.items():\n                for station in part_spec.keys():\n                    if station not in self._objects:\n                        raise ValueError(\n                                f\"Spec for part '{part_name}' in carrier '{carrier_name}' \"\n                                f\"contains unkown station '{station}'\"\n                        )\n\n    def _build_states(self):\n        \"\"\"\n        Builds the states of the line objects as well as the LineState\n        \"\"\"\n        object_states = {}\n\n        for name, obj in self._objects.items():\n            obj.init(self.random)\n            object_states[name] = obj.state\n\n        self.state = LineStates(object_states, self.env)\n\n    def reset(self, random_state=None):\n        \"\"\"\n        Resets the simulation.\n        \"\"\"\n        self.random = np.random.RandomState(random_state)\n        self._make_env()\n        self._make_objects()\n\n        self._build_states()\n        self._register_objects_at_env()\n\n        self.end_step = 0\n        self.env.process(self.step_event())\n\n    def _assert_one_sink(self):\n        if len([c for c in self._objects.values() if isinstance(c, Sink)]) != 1:\n            raise ValueError(\n                \"Number of sinks does not match\"\n                \"Currently, only scenarios with exactly one sink are allowed\"\n            )\n\n    def get_sink(self):\n        sinks = [s for s in self._objects.values() if isinstance(s, Sink)]\n        self._assert_one_sink()\n        return sinks[0]\n\n    def get_n_scrap_parts(self):\n        \"\"\"\n        Returns the number of produced parts up to now\n        \"\"\"\n        return self.state.get_n_scrap_parts()\n\n    def get_n_parts_produced(self):\n        \"\"\"\n        Returns the number of produced parts up to now\n        \"\"\"\n        return self.state.get_n_parts_produced()\n\n    def get_uptime(self, lookback=None):\n        \"\"\"\n        Returns the uptime of the line \n        \"\"\"\n        return self.state.get_uptime(lookback=lookback)\n\n    def build(self):\n        \"\"\"\n        This function should add objects of the LineObject class as attributes\n        \"\"\"\n        raise NotImplementedError()\n\n    def _register_objects_at_env(self):\n        \"\"\"\n        Registers all line objects at the simpy simulation environment.\n        \"\"\"\n        for o in self._objects.values():\n            o.register(self.env)\n\n    def _draw(self, screen, actions=None):\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                break\n\n        screen.fill('white')\n\n        font = pygame.font.SysFont(None, 20)\n\n        time = font.render('T={:.2f}'.format(self.env.now), True, 'black')\n        n_parts = font.render(\n            f'#Parts={self.get_n_parts_produced()}', True, 'black'\n        )\n\n        screen.blit(time, time.get_rect(center=(30, 30)))\n        screen.blit(n_parts, n_parts.get_rect(center=(30, 50)))\n\n        # Draw objects, first connectors, then stations\n        self._draw_connectors(screen)\n        self._draw_stations(screen)\n        if actions:\n            self._draw_actions(screen, actions)\n        pygame.display.flip()\n\n    def _draw_actions(self, screen, actions):\n        font = pygame.font.SysFont(None, 20)\n        actions = font.render(f'{actions}', True, 'black')\n        screen.blit(actions, actions.get_rect(center=(500, 30)))\n        pygame.display.flip()\n\n    def _draw_stations(self, screen):\n        self._draw_objects_of_type(screen, Station)\n\n    def _draw_connectors(self, screen):\n        self._draw_objects_of_type(screen, Connector)\n\n    def _draw_objects_of_type(self, screen, object_type):\n        for name, obj in self._objects.items():\n            if isinstance(obj, object_type):\n                obj._draw(screen)\n\n    def setup_draw(self):\n        pygame.init()\n        x = []\n        y = []\n        for o in self._objects.values():\n            o.setup_draw()\n            if isinstance(o, Station):\n                assert hasattr(o, \"position\"), f\"Please provide position for {Station.name}\"\n                x.append(o.position[0])\n                y.append(o.position[1])\n\n        return pygame.display.set_mode((max(x) + 100, max(y) + 100))\n\n    def teardown_draw(self):\n        pygame.quit()\n\n    def apply(self, values):\n        for object_name in values.keys():\n            self._objects[object_name].apply(values[object_name])\n\n    def step(self, simulation_end=None):\n        \"\"\"\n        Step to the next state of the line\n        Args:\n            simulation_end (int):\n                Time until terminated flag is returned as True. If None\n                terminated is always False.\n        \"\"\"\n        terminated = False\n\n        # The end of the the current step, excluding the event execution\n        # i.e. execute all events where scheudled_time &lt; end_step\n        self.end_step = self.end_step + self.step_size\n\n        while True:\n            if self.env.peek() &gt; self.end_step:\n                self.state.log()\n                # If the next event is scheduled after simulation end\n                if simulation_end is not None and self.env.peek() &gt; simulation_end:\n                    terminated = True\n\n                return self.state, terminated\n\n            self.env.step()\n\n    def step_event(self):\n        \"\"\"\n        Ensures that there is an Event scheduled for `self.step_size` intervals\n        The step function is only able to stop the simulation if an Event is scheduled.\n        \"\"\"\n        while True:\n            yield self.env.timeout(self.step_size)\n\n    def run(\n        self,\n        simulation_end,\n        agent=None,\n        show_status=True,\n        visualize=False,\n        capture_screen=False,\n    ):\n        \"\"\"\n        Args:\n            simulation_end (float): Time until the simulation stops\n            agent (lineflow.models.reinforcement_learning.agents): An Agent that interacts with a\n                line. Can also be just a policy if an __call__ method exists like in the BaseAgent\n                class.\n            show_status (bool): Show progress bar for each simulation episode\n            visualize (bool): If true, line visualization is opened\n            capture_screen (bool): Captures last Time frame when screen should be recorded\n        \"\"\"\n\n        if visualize:\n            # Stations first, then connectors\n            screen = self.setup_draw()\n\n        # Register objects when simulation is initially started\n        if len(self.env._queue) == 0:\n            self._register_objects_at_env()\n\n        now = 0\n        actions = None\n        pbar = tqdm(\n            total=simulation_end,\n            bar_format='{desc}: {percentage:3.2f}%|{bar:50}|',\n            disable=not show_status,\n        )\n\n        while self.env.now &lt; simulation_end:\n            pbar.update(self.env.now - now)\n            now = self.env.now\n            try:\n                self.step()\n            except simpy.core.EmptySchedule:\n                logger.warning('Simulation in dead-lock - end early')\n                break\n\n            if agent is not None:\n                actions = agent(self.state, self.env)\n                self.apply(actions)\n\n            if visualize:\n                if actions is not None:\n                    self._draw(screen, actions)\n                else:\n                    self._draw(screen)\n\n        if capture_screen and visualize:\n            pygame.image.save(screen, f\"{self.name}.png\")\n\n        if visualize:\n            self.teardown_draw()\n\n    def get_observations(self, object_name=None):\n        \"\"\"\n        \"\"\"\n\n        df = self.state.df()\n\n        if object_name is None:\n            return df\n        else:\n            cols = [c for c in df.columns if c.startswith(object_name)]\n            cols = cols + ['T_start', 'T_end']\n            return df[cols].rename(\n                columns={\n                    c: c.replace(object_name + '_', '') for c in cols\n                }\n            )\n\n    def __getitem__(self, name):\n        return self._objects[name]\n</code></pre>"},{"location":"api.html#lineflow.simulation.line.Line.build","title":"<code>build()</code>","text":"<p>This function should add objects of the LineObject class as attributes</p> Source code in <code>lineflow/simulation/line.py</code> <pre><code>def build(self):\n    \"\"\"\n    This function should add objects of the LineObject class as attributes\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api.html#lineflow.simulation.line.Line.get_n_parts_produced","title":"<code>get_n_parts_produced()</code>","text":"<p>Returns the number of produced parts up to now</p> Source code in <code>lineflow/simulation/line.py</code> <pre><code>def get_n_parts_produced(self):\n    \"\"\"\n    Returns the number of produced parts up to now\n    \"\"\"\n    return self.state.get_n_parts_produced()\n</code></pre>"},{"location":"api.html#lineflow.simulation.line.Line.get_n_scrap_parts","title":"<code>get_n_scrap_parts()</code>","text":"<p>Returns the number of produced parts up to now</p> Source code in <code>lineflow/simulation/line.py</code> <pre><code>def get_n_scrap_parts(self):\n    \"\"\"\n    Returns the number of produced parts up to now\n    \"\"\"\n    return self.state.get_n_scrap_parts()\n</code></pre>"},{"location":"api.html#lineflow.simulation.line.Line.get_observations","title":"<code>get_observations(object_name=None)</code>","text":"Source code in <code>lineflow/simulation/line.py</code> <pre><code>def get_observations(self, object_name=None):\n    \"\"\"\n    \"\"\"\n\n    df = self.state.df()\n\n    if object_name is None:\n        return df\n    else:\n        cols = [c for c in df.columns if c.startswith(object_name)]\n        cols = cols + ['T_start', 'T_end']\n        return df[cols].rename(\n            columns={\n                c: c.replace(object_name + '_', '') for c in cols\n            }\n        )\n</code></pre>"},{"location":"api.html#lineflow.simulation.line.Line.get_uptime","title":"<code>get_uptime(lookback=None)</code>","text":"<p>Returns the uptime of the line</p> Source code in <code>lineflow/simulation/line.py</code> <pre><code>def get_uptime(self, lookback=None):\n    \"\"\"\n    Returns the uptime of the line \n    \"\"\"\n    return self.state.get_uptime(lookback=lookback)\n</code></pre>"},{"location":"api.html#lineflow.simulation.line.Line.info","title":"<code>info()</code>","text":"<p>Returns additional Information about the line</p> Source code in <code>lineflow/simulation/line.py</code> <pre><code>def info(self):\n    \"\"\"\n    Returns additional Information about the line\n    \"\"\"\n    general = {\n        \"name\": self.name,\n        \"T\": self.env.now,\n        \"n_parts\": self.get_n_parts_produced(),\n        \"n_scrap_parts\": self.get_n_scrap_parts(),\n    }\n\n    additional = {\n        f\"{station}_{attribute}\": self.state.objects[station].states[attribute].value\n        for station, attribute in self._info\n    }\n    return {**general, **additional}\n</code></pre>"},{"location":"api.html#lineflow.simulation.line.Line.reset","title":"<code>reset(random_state=None)</code>","text":"<p>Resets the simulation.</p> Source code in <code>lineflow/simulation/line.py</code> <pre><code>def reset(self, random_state=None):\n    \"\"\"\n    Resets the simulation.\n    \"\"\"\n    self.random = np.random.RandomState(random_state)\n    self._make_env()\n    self._make_objects()\n\n    self._build_states()\n    self._register_objects_at_env()\n\n    self.end_step = 0\n    self.env.process(self.step_event())\n</code></pre>"},{"location":"api.html#lineflow.simulation.line.Line.run","title":"<code>run(simulation_end, agent=None, show_status=True, visualize=False, capture_screen=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>simulation_end</code> <code>float</code> <p>Time until the simulation stops</p> required <code>agent</code> <code>agents</code> <p>An Agent that interacts with a line. Can also be just a policy if an call method exists like in the BaseAgent class.</p> <code>None</code> <code>show_status</code> <code>bool</code> <p>Show progress bar for each simulation episode</p> <code>True</code> <code>visualize</code> <code>bool</code> <p>If true, line visualization is opened</p> <code>False</code> <code>capture_screen</code> <code>bool</code> <p>Captures last Time frame when screen should be recorded</p> <code>False</code> Source code in <code>lineflow/simulation/line.py</code> <pre><code>def run(\n    self,\n    simulation_end,\n    agent=None,\n    show_status=True,\n    visualize=False,\n    capture_screen=False,\n):\n    \"\"\"\n    Args:\n        simulation_end (float): Time until the simulation stops\n        agent (lineflow.models.reinforcement_learning.agents): An Agent that interacts with a\n            line. Can also be just a policy if an __call__ method exists like in the BaseAgent\n            class.\n        show_status (bool): Show progress bar for each simulation episode\n        visualize (bool): If true, line visualization is opened\n        capture_screen (bool): Captures last Time frame when screen should be recorded\n    \"\"\"\n\n    if visualize:\n        # Stations first, then connectors\n        screen = self.setup_draw()\n\n    # Register objects when simulation is initially started\n    if len(self.env._queue) == 0:\n        self._register_objects_at_env()\n\n    now = 0\n    actions = None\n    pbar = tqdm(\n        total=simulation_end,\n        bar_format='{desc}: {percentage:3.2f}%|{bar:50}|',\n        disable=not show_status,\n    )\n\n    while self.env.now &lt; simulation_end:\n        pbar.update(self.env.now - now)\n        now = self.env.now\n        try:\n            self.step()\n        except simpy.core.EmptySchedule:\n            logger.warning('Simulation in dead-lock - end early')\n            break\n\n        if agent is not None:\n            actions = agent(self.state, self.env)\n            self.apply(actions)\n\n        if visualize:\n            if actions is not None:\n                self._draw(screen, actions)\n            else:\n                self._draw(screen)\n\n    if capture_screen and visualize:\n        pygame.image.save(screen, f\"{self.name}.png\")\n\n    if visualize:\n        self.teardown_draw()\n</code></pre>"},{"location":"api.html#lineflow.simulation.line.Line.step","title":"<code>step(simulation_end=None)</code>","text":"<p>Step to the next state of the line Args:     simulation_end (int):         Time until terminated flag is returned as True. If None         terminated is always False.</p> Source code in <code>lineflow/simulation/line.py</code> <pre><code>def step(self, simulation_end=None):\n    \"\"\"\n    Step to the next state of the line\n    Args:\n        simulation_end (int):\n            Time until terminated flag is returned as True. If None\n            terminated is always False.\n    \"\"\"\n    terminated = False\n\n    # The end of the the current step, excluding the event execution\n    # i.e. execute all events where scheudled_time &lt; end_step\n    self.end_step = self.end_step + self.step_size\n\n    while True:\n        if self.env.peek() &gt; self.end_step:\n            self.state.log()\n            # If the next event is scheduled after simulation end\n            if simulation_end is not None and self.env.peek() &gt; simulation_end:\n                terminated = True\n\n            return self.state, terminated\n\n        self.env.step()\n</code></pre>"},{"location":"api.html#lineflow.simulation.line.Line.step_event","title":"<code>step_event()</code>","text":"<p>Ensures that there is an Event scheduled for <code>self.step_size</code> intervals The step function is only able to stop the simulation if an Event is scheduled.</p> Source code in <code>lineflow/simulation/line.py</code> <pre><code>def step_event(self):\n    \"\"\"\n    Ensures that there is an Event scheduled for `self.step_size` intervals\n    The step function is only able to stop the simulation if an Event is scheduled.\n    \"\"\"\n    while True:\n        yield self.env.timeout(self.step_size)\n</code></pre>"},{"location":"api.html#lineflow.simulation.stations.Assembly","title":"<code>Assembly</code>","text":"<p>               Bases: <code>Station</code></p> <p>Assembly takes a carrier from <code>buffer_in</code> and <code>buffer_component</code>, puts the parts of the component carrier on the carrier that came from buffer_in, and pushes that carrier to buffer_out and pushes the component carrier to buffer_return if a buffer return exists, otherwise these carriers are lost.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the station</p> required <code>processing_time</code> <code>float</code> <p>Time until parts are moved from component carrier to main carrier</p> <code>5</code> <code>position</code> <code>tuple</code> <p>X and Y position in the visualization</p> <code>None</code> <code>buffer_return</code> <code>Buffer</code> <p>The buffer to put the old component carriers on</p> <code>None</code> <code>processing_std</code> <code>float</code> <p>The standard deviation of the processing time</p> <code>None</code> Source code in <code>lineflow/simulation/stations.py</code> <pre><code>class Assembly(Station):\n    \"\"\"\n    Assembly takes a carrier from `buffer_in` and `buffer_component`, puts the parts of the component\n    carrier on the carrier that came from buffer_in, and pushes that carrier to buffer_out and\n    pushes the component carrier to buffer_return if a buffer return exists, otherwise these\n    carriers are lost.\n\n    Args:\n        name (str): Name of the station\n        processing_time (float): Time until parts are moved from component carrier to main carrier\n        position (tuple): X and Y position in the visualization\n        buffer_return (lineflow.simulation.connectors.Buffer): The buffer to\n            put the old component carriers on\n        processing_std (float): The standard deviation of the processing time\n    \"\"\"\n    def __init__(\n        self,\n        name,\n        buffer_in=None,\n        buffer_out=None,\n        buffer_component=None,\n        processing_time=5,\n        position=None,\n        buffer_return=None,\n        processing_std=None,\n        NOK_part_error_time=2,\n        worker_pool=None,\n    ):\n\n        super().__init__(\n            name=name,\n            position=position,\n            processing_time=processing_time,\n            processing_std=processing_std,\n            worker_pool=worker_pool,\n        )\n        self.NOK_part_error_time = NOK_part_error_time\n\n        if buffer_in is not None:\n            self._connect_to_input(buffer_in)\n\n        if buffer_out is not None:\n            self._connect_to_output(buffer_out)\n\n        if buffer_component is not None:\n            self.buffer_component = buffer_component.connect_to_output(self)\n\n        if buffer_return is not None:\n            self.buffer_return = buffer_return.connect_to_input(self)\n\n    def init_state(self):\n        self.state = ObjectStates(\n            DiscreteState('on', categories=[True, False], is_actionable=False, is_observable=False),\n            DiscreteState('mode', categories=['working', 'waiting', 'failing']),\n            TokenState(name='carrier', is_observable=False),\n            TokenState(name='carrier_component', is_observable=False),\n            CountState('n_scrap_parts', is_actionable=False, is_observable=True),\n            CountState('n_workers', is_actionable=False, is_observable=True, vmin=0),\n            NumericState('processing_time', is_actionable=False, is_observable=True, vmin=0),\n        )\n        self.state['on'].update(True)\n        self.state['mode'].update(\"waiting\")\n        self.state['carrier'].update(None)\n        self.state['carrier_component'].update(None)\n        self.state['n_scrap_parts'].update(0)\n        self.state['processing_time'].update(self.processing_time)\n        self.state['n_workers'].update(self.n_workers)\n\n    def connect_to_component_input(self, station, *args, **kwargs):\n        buffer = Buffer(name=f\"Buffer_{station.name}_to_{self.name}\", *args, **kwargs)\n        self.buffer_component = buffer.connect_to_output(self)\n        station._connect_to_output(buffer)\n\n    def connect_to_component_return(self, station, *args, **kwargs):\n        buffer = Buffer(name=f\"Buffer_{self.name}_to_{station.name}\", *args, **kwargs)\n        self.buffer_return = buffer.connect_to_input(self)\n        station._connect_to_input(buffer)\n\n    def _has_invalid_components_on_carrier(self, carrier):\n        \"\"\"\n        Checks if any of the components on the carrier is not valid for assembly. In this case,\n        `True` is returned. Otherwise, `False` is returned.\n        \"\"\"\n        for component in carrier:\n            if not component.is_valid_for_assembly(self.name):\n                return True\n        return False\n\n    def _draw_info(self, screen):\n        self._draw_n_workers(screen)\n\n    def run(self):\n\n        while True:\n            if self.is_on():\n\n                yield self.env.process(self.request_workers())\n                self.state['n_workers'].update(self.n_workers)\n                # Wait to get part from buffer_in\n                yield self.env.process(self.set_to_waiting())\n                carrier = yield self.env.process(self.buffer_in())\n\n                # Update current_carrier and count parts of carrier\n                self.state['carrier'].update(carrier.name)\n\n                # Run until carrier with components each having a valid assembly condition is\n                # received\n                while True:\n                    # Wait to get component\n                    carrier_component = yield self.env.process(self.buffer_component())\n                    self.state['carrier_component'].update(carrier_component.name)\n\n                    # Check component\n                    if self._has_invalid_components_on_carrier(carrier_component):\n                        yield self.env.process(self.set_to_error())\n                        yield self.env.timeout(self.NOK_part_error_time)\n                        self.state['n_scrap_parts'].increment()\n\n                        # send carrier back\n                        if hasattr(self, 'buffer_return'):\n                            carrier_component.parts.clear()\n                            yield self.env.process(self.buffer_return(carrier_component))\n                        yield self.env.process(self.set_to_waiting())\n                        continue\n\n                    else:\n                        # All components are valid, proceed with assembly\n                        break\n\n                # Process components\n                yield self.env.process(self.set_to_work())\n                processing_time = self._sample_exp_time(\n                    time=self.processing_time + carrier.get_additional_processing_time(self.name),\n                    scale=self.processing_std,\n                )\n                yield self.env.timeout(processing_time)\n                self.state['processing_time'].update(processing_time)\n\n                for component in carrier_component:\n                    carrier.assemble(component)\n\n                # Release workers\n                self.release_workers()\n\n                # Place carrier on buffer_out\n                yield self.env.process(self.set_to_waiting())\n                yield self.env.process(self.buffer_out(carrier))\n                self.state['carrier'].update(None)\n\n                # send component carrier back\n                if hasattr(self, 'buffer_return'):\n                    yield self.env.process(self.buffer_return(carrier_component))\n\n                self.state['carrier_component'].update(None)\n\n            else:\n                yield self.turn_off()\n</code></pre>"},{"location":"api.html#lineflow.simulation.stations.Magazine","title":"<code>Magazine</code>","text":"<p>               Bases: <code>Station</code></p> <p>Magazine station manages carriers.</p> <p>The Magazine gets carriers from buffer_in and stores them in the magazine. Afterwards it takes a carrier from its magazine and pushes the carrier to buffer_out. If unlimited_carriers is True no buffer_in is needed.</p> <p>Parameters:</p> Name Type Description Default <code>unlimited_carriers</code> <code>bool</code> <p>If True, the Magazine will have an unlimited amount of carriers available</p> <code>True</code> <code>carriers_in_magazine</code> <code>int</code> <p>Number of carriers in the magazine</p> <code>0</code> <code>carrier_getting_time</code> <code>float</code> <p>Time to get a carrier from the magazine</p> <code>2</code> <code>actionable_magazine</code> <code>bool</code> <p>If True, carriers in the magazine is in an actionable state</p> <code>True</code> <code>carrier_capacity</code> <code>int</code> <p>Defines how many parts can be assembled on a carrier. If set to default (infinity) or &gt; 15, carrier will be visualized with one part.</p> <code>inf</code> Source code in <code>lineflow/simulation/stations.py</code> <pre><code>class Magazine(Station):\n    '''\n    Magazine station manages carriers.\n\n    The Magazine gets carriers from buffer_in and stores them in the\n    magazine. Afterwards it takes a carrier from its magazine and pushes the\n    carrier to buffer_out.\n    If unlimited_carriers is True no buffer_in is needed.\n\n    Args:\n        unlimited_carriers (bool): If True, the Magazine will have an unlimited amount of carriers available\n        carriers_in_magazine (int): Number of carriers in the magazine\n        carrier_getting_time (float): Time to get a carrier from the magazine\n        actionable_magazine (bool): If True, carriers in the magazine is in an actionable state\n        carrier_capacity (int): Defines how many parts can be assembled on a carrier. If set to default (infinity) or &gt; 15, carrier will be visualized with one part.\n    '''\n    def __init__(\n        self,\n        name,\n        buffer_in=None,\n        buffer_out=None,\n        position=None,\n        unlimited_carriers=True,\n        carrier_capacity=np.inf,\n        actionable_magazine=True,\n        carrier_getting_time=2,\n        carriers_in_magazine=0,\n        carrier_specs=None,\n        carrier_min_creation=1,\n        carrier_max_creation=None,\n    ):\n        super().__init__(\n            name=name,\n            position=position,\n        )\n        self._assert_init_args(buffer_in, unlimited_carriers, carriers_in_magazine, carrier_capacity)\n\n        if buffer_in is not None:\n            self._connect_to_input(buffer_in)\n        if buffer_out is not None:\n            self._connect_to_output(buffer_out)\n\n        self.actionable_magazine = actionable_magazine\n        self.init_carriers_in_magazine = carriers_in_magazine\n        self.carrier_getting_time = carrier_getting_time\n\n        if carrier_specs is None:\n            carrier_specs = {\"carrier\": {\"part\": {}}}\n        self.carrier_specs = carrier_specs\n\n        self.unlimited_carriers = unlimited_carriers\n        self.carrier_capacity = carrier_capacity\n        self.carrier_id = 1\n        self.carrier_min_creation = carrier_min_creation\n        self.carrier_max_creation = carrier_max_creation if carrier_max_creation is not None else 2*carrier_min_creation\n        self._carrier_counter = 0\n\n    def init_state(self):\n\n        self.state = ObjectStates(\n            DiscreteState('on', categories=[True, False], is_actionable=False, is_observable=False),\n            DiscreteState('mode', categories=['working', 'waiting', 'failing']),\n            CountState('carriers_in_magazine', is_actionable=self.actionable_magazine, is_observable=True),\n            TokenState(name='carrier', is_observable=False),\n            TokenState(name='part', is_observable=False),\n        )\n\n        self.state['carriers_in_magazine'].update(self.init_carriers_in_magazine)\n        self.state['on'].update(True)\n        self.state['mode'].update(\"waiting\")\n        self.state['carrier'].update(None)\n        self.state['part'].update(None)\n\n    def _assert_init_args(self, buffer_in, unlimited_carriers, carriers_in_magazine, carrier_capacity):\n        if carrier_capacity &gt; 15:\n            warnings.warn(\"If carrier_capacity &gt; 15, visualization of parts on carriers is restriced and carrier will be visualized with one part\")\n\n        if not isinstance(carrier_capacity, int) and carrier_capacity != np.inf:\n            raise AttributeError(\"Type of carrier capacity must be int or np.inf\")\n\n        if not unlimited_carriers and carriers_in_magazine == 0:\n            raise AttributeError(f\"unlimited_carriers is {unlimited_carriers} and cell also has 0 carriers in magazine\")\n\n        if unlimited_carriers and carriers_in_magazine &gt; 0:\n            raise AttributeError(f\"unlimited_carriers is {unlimited_carriers} and cell has more than 0 carriers in magazine\")\n\n        if buffer_in and unlimited_carriers:\n                raise AttributeError(f\"Only magazine or unlimited_carriers {unlimited_carriers} is required\")\n\n    def create_carrier(self):\n        if self._carrier_counter == 0:\n            self._current_carrier_spec = self.random.choice(list(self.carrier_specs.keys()))\n            self._carrier_counter = self.random.randint(\n                self.carrier_min_creation, \n                self.carrier_max_creation + 1,\n            )\n\n        name = f'{self.name}_{self._current_carrier_spec}_{self.carrier_id}'\n        carrier = Carrier(\n            self.env, \n            name=name, \n            capacity=self.carrier_capacity, \n            part_specs=self.carrier_specs[self._current_carrier_spec],\n        )\n        self.carrier_id += 1\n        self._carrier_counter -= 1\n\n        return carrier\n\n    def _initial_fill_magazine(self, n_carriers):\n        # attribute needs to be set here as env is not available in __init__()\n        self.magazine = simpy.Store(self.env)\n        for i in range(n_carriers):\n            carrier = self.create_carrier()\n            self.magazine.put(carrier)\n\n    def get_carrier_from_magazine(self):\n        yield self.env.process(self._update_magazine())\n        yield self.env.timeout(self.carrier_getting_time)\n\n        while True:\n            yield self.env.process(self._update_magazine())\n            yield self.env.process(self.set_to_work())\n            if len(self.magazine.items) &gt; 0:\n                carrier = yield self.magazine.get()\n                break\n            else:\n                yield self.env.process(self.set_to_waiting())\n                yield self.env.timeout(1)\n\n        self.state['carriers_in_magazine'].decrement()\n        return carrier\n\n    def _buffer_in_to_magazine(self):\n        while True:\n            carrier = yield self.env.process(self.buffer_in())\n            yield self.env.process(self.add_carrier_to_magazine(carrier))\n\n    def add_carrier_to_magazine(self, carrier):\n        yield self.magazine.put(carrier)\n        self.state['carriers_in_magazine'].increment()\n\n    def _update_magazine(self):\n        '''\n        update the magazine according to state\n        '''\n        should = self.state['carriers_in_magazine'].value\n        current = len(self.magazine.items)\n        diff = should - current\n        if diff &gt; 0:\n            for i in range(diff):\n                carrier = self.create_carrier()\n                self.magazine.put(carrier)\n\n        if diff &lt; 0:\n            for i in range(abs(diff)):\n                carrier = yield self.magazine.get()\n\n    def _draw_info(self, screen):\n        self._draw_n_carriers(screen)\n\n    def get_carrier(self):\n        # First check if Magazine is allowed to create unlimited carriers\n        if self.unlimited_carriers:\n            yield self.env.timeout(self.carrier_getting_time)\n            carrier = self.create_carrier()\n\n        # Second check magazine\n        else:\n            carrier = yield self.env.process(self.get_carrier_from_magazine())\n        self.state[\"carrier\"].update(carrier.name)\n        return carrier\n\n    def run(self):\n        # Initially fill the magazine with carriers\n        self._initial_fill_magazine(self.state['carriers_in_magazine'].value)\n\n        if hasattr(self, 'buffer_in'):\n            self.env.process(self._buffer_in_to_magazine())\n\n        while True:\n            if self.is_on():\n                # Get carrier from Magazine\n                yield self.env.process(self.set_to_work())\n                carrier = yield self.env.process(self.get_carrier())\n\n                # Wait to place carrier to buffer_out\n                yield self.env.process(self.set_to_waiting())\n                yield self.env.process(self.buffer_out(carrier))\n                self.state['carrier'].update(None)\n            else:\n                yield self.turn_off()\n</code></pre>"},{"location":"api.html#lineflow.simulation.stations.Process","title":"<code>Process</code>","text":"<p>               Bases: <code>Station</code></p> <p>Process stations take a carrier as input, process the carrier, and push it onto buffer_out Args:     processing_std: Standard deviation of the processing time     rework_probability: Probability of a carrier to be reworked (takes 2x the time)     position (tuple): X and Y position in visualization</p> Source code in <code>lineflow/simulation/stations.py</code> <pre><code>class Process(Station):\n    '''\n    Process stations take a carrier as input, process the carrier, and push it onto buffer_out\n    Args:\n        processing_std: Standard deviation of the processing time\n        rework_probability: Probability of a carrier to be reworked (takes 2x the time)\n        position (tuple): X and Y position in visualization\n    '''\n\n    def __init__(\n        self,\n        name,\n        buffer_in=None,\n        buffer_out=None,\n        processing_time=5,\n        position=None,\n        processing_std=None,\n        rework_probability=0,\n        worker_pool=None,\n\n    ):\n\n        super().__init__(\n            name=name,\n            position=position,\n            processing_time=processing_time,\n            processing_std=processing_std,\n            rework_probability=rework_probability,\n            worker_pool=worker_pool,\n        )\n\n        if buffer_in is not None:\n            self._connect_to_input(buffer_in)\n\n        if buffer_out is not None:\n            self._connect_to_output(buffer_out)\n\n    def init_state(self):\n\n        self.state = ObjectStates(\n            DiscreteState('on', categories=[True, False], is_actionable=False, is_observable=False),\n            DiscreteState('mode', categories=['working', 'waiting', 'failing']),\n            TokenState(name='carrier', is_observable=False),\n            NumericState('processing_time', is_actionable=False, is_observable=True, vmin=0),\n            CountState('n_workers', is_actionable=False, is_observable=True, vmin=0),\n        )\n        self.state['on'].update(True)\n        self.state['mode'].update(\"waiting\")\n        self.state['carrier'].update(None)\n        self.state['processing_time'].update(self.processing_time)\n        self.state['n_workers'].update(self.n_workers)\n\n    def _draw_info(self, screen):\n        self._draw_n_workers(screen)\n\n    def run(self):\n\n        while True:\n            if self.is_on():\n                yield self.env.process(self.request_workers())\n                self.state['n_workers'].update(self.n_workers)\n                # Wait to get part from buffer_in\n                yield self.env.process(self.set_to_waiting())\n                carrier = yield self.env.process(self.buffer_in())\n                self.state['carrier'].update(carrier.name)\n\n                yield self.env.process(self.set_to_work())\n\n                processing_time = self._sample_exp_time(\n                    time=self.processing_time + carrier.get_additional_processing_time(self.name),\n                    scale=self.processing_std,\n                    rework_probability=self.rework_probability,\n                )\n                yield self.env.timeout(processing_time)\n                self.state['processing_time'].update(processing_time)\n\n                # Release workers\n                self.release_workers()\n\n                # Wait to place carrier to buffer_out\n                yield self.env.process(self.set_to_waiting())\n                yield self.env.process(self.buffer_out(carrier))\n                self.state['carrier'].update(None)\n\n            else:\n                yield self.turn_off()\n</code></pre>"},{"location":"api.html#lineflow.simulation.stations.Sink","title":"<code>Sink</code>","text":"<p>               Bases: <code>Station</code></p> <p>The Sink takes carriers from buffer_in. It removes the parts of the carrier and either destroys it or puts them to buffer_out if one exists.</p> <p>Parameters:</p> Name Type Description Default <code>processing_std</code> <code>float</code> <p>The standard deviation of the processing time.</p> <code>None</code> <code>position</code> <code>tuple</code> <p>X and Y position in the visualization.</p> <code>None</code> Source code in <code>lineflow/simulation/stations.py</code> <pre><code>class Sink(Station):\n    \"\"\"\n    The Sink takes carriers from buffer_in. It removes the parts of the carrier and either\n    destroys it or puts them to buffer_out if one exists.\n\n    Args:\n        processing_std (float): The standard deviation of the processing time.\n        position (tuple): X and Y position in the visualization.\n    \"\"\"\n    def __init__(\n        self,\n        name,\n        buffer_in=None,\n        buffer_out=None,\n        processing_time=2,\n        processing_std=None,\n        position=None,\n    ):\n        super().__init__(\n            name=name,\n            processing_time=processing_time,\n            processing_std=processing_std,\n            position=position,\n        )\n\n        if buffer_in is not None:\n            self._connect_to_input(buffer_in)\n        if buffer_out is not None:\n            self._connect_to_output(buffer_out)\n\n    def init_state(self):\n\n        self.state = ObjectStates(\n            DiscreteState('on', categories=[True, False], is_actionable=False, is_observable=False),\n            DiscreteState('mode', categories=['working', 'waiting', 'failing']),\n            CountState('n_parts_produced', is_actionable=False, is_observable=False),\n            TokenState(name='carrier', is_observable=False),\n        )\n\n        self.state['on'].update(True)\n        self.state['mode'].update(\"waiting\")\n        self.state['n_parts_produced'].update(0)\n        self.state['mode'].update(\"waiting\")\n        self.state['carrier'].update(None)\n\n    def remove(self, carrier):\n\n        processing_time = self._sample_exp_time(\n            time=self.processing_time,\n            scale=self.processing_std,\n        )\n        yield self.env.timeout(processing_time)\n        self.state['n_parts_produced'].increment()\n\n        if hasattr(self, 'buffer_out'):\n            yield self.env.process(self.set_to_waiting())\n            carrier.parts.clear()\n            yield self.env.process(self.buffer_out(carrier))\n\n    def run(self):\n\n        while True:\n            if self.is_on():\n                yield self.env.process(self.set_to_waiting())\n                carrier = yield self.env.process(self.buffer_in())\n                yield self.env.process(self.set_to_work())\n                self.state['carrier'].update(carrier.name)\n\n                # Wait to place carrier to buffer_out\n                yield self.env.process(self.remove(carrier))\n                self.state['carrier'].update(None)\n\n            else:\n                yield self.turn_off()\n</code></pre>"},{"location":"api.html#lineflow.simulation.stations.Source","title":"<code>Source</code>","text":"<p>               Bases: <code>Station</code></p> <p>Source station generating parts on carriers.</p> <p>The Source takes carriers from buffer_in, creates a part, places that part onto the carrier, and pushes the carrier onto the buffer_out. If unlimited carriers is True, no buffer_in is needed and no magazine.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the Cell</p> required <code>carrier_specs</code> <code>dict</code> <p>Nested dict. Top level descripes carrier types, each consists of a dict specifying different parts setup on the carrier at the source. The part level specifies how the part behaves at future processes along the layout. For instance a spec <code>{'C': {'Part1': {'Process1': {'assembly_condition': 5}, 'Process2': {'extra_processing_time': 10}}}}</code>  tells that the produced carrier has one part <code>Part1</code> that has to fullfill an assembly condition of <code>5</code>  at station <code>Process1</code> and gets an additional processing time of <code>10</code> at <code>Process2</code>.</p> <code>None</code> <code>buffer_in</code> <code>Buffer</code> <p>Buffer in</p> <code>None</code> <code>buffer_out</code> <code>obj</code> <p>Buffer out</p> <code>None</code> <code>processing_time</code> <code>float</code> <p>Time it takes to put part on carrier (carrier needs to be available)</p> <code>2</code> <code>processing_std</code> <code>float</code> <p>Standard deviation of processing time</p> <code>None</code> <code>waiting_time</code> <code>float</code> <p>Time to wait between pushing a carrier out and taking the next one</p> <code>0</code> <code>position</code> <code>tuple</code> <p>X and Y position in visualization</p> <code>None</code> <code>unlimited_carriers</code> <code>bool</code> <p>If source has the ability to create unlimited carriers</p> <code>False</code> <code>carrier_capacity</code> <code>int</code> <p>Defines how many parts can be assembled on a carrier. If set to default (infinity) or &gt; 15, carrier will be visualized with one part.</p> <code>inf</code> <code>carrier_min_creation</code> <code>int</code> <p>Minimum number of carriers of same spec created subsequentially</p> <code>1</code> <code>carrier_max_creation</code> <code>int</code> <p>Maximum number of carriers of same spec created subsequentially</p> <code>None</code> Source code in <code>lineflow/simulation/stations.py</code> <pre><code>class Source(Station):\n    '''\n    Source station generating parts on carriers.\n\n    The Source takes carriers from buffer_in, creates a part, places that part\n    onto the carrier, and pushes the carrier onto the buffer_out.\n    If unlimited carriers is True, no buffer_in is needed and no magazine.\n\n    Args:\n        name (str): Name of the Cell\n        carrier_specs (dict): Nested dict. Top level descripes carrier types, each consists of a\n            dict specifying different parts setup on the carrier at the source. The part level\n            specifies how the part behaves at future processes along the layout. For instance a spec\n            `{'C': {'Part1': {'Process1': {'assembly_condition': 5}, 'Process2': {'extra_processing_time': 10}}}}` \n            tells that the produced carrier has one part `Part1` that has to fullfill an assembly condition of `5` \n            at station `Process1` and gets an additional processing time of `10` at `Process2`.\n        buffer_in (lineflow.simulation.connectors.Buffer, optional): Buffer in\n        buffer_out (obj): Buffer out\n        processing_time (float): Time it takes to put part on carrier (carrier needs to be\n            available)\n        processing_std (float): Standard deviation of processing time\n        waiting_time (float): Time to wait between pushing a carrier out and taking the next one\n        position (tuple): X and Y position in visualization\n        unlimited_carriers (bool): If source has the ability to create unlimited carriers\n        carrier_capacity (int): Defines how many parts can be assembled on a carrier. If set to\n            default (infinity) or &gt; 15, carrier will be visualized with one part.\n        carrier_min_creation (int): Minimum number of carriers of same spec created subsequentially\n        carrier_max_creation (int): Maximum number of carriers of same spec created subsequentially\n\n    '''\n    def __init__(\n        self,\n        name,\n        buffer_in=None,\n        buffer_out=None,\n        processing_time=2,\n        processing_std=None,\n        waiting_time=0,\n        waiting_time_step=0.5,\n        position=None,\n        actionable_magazin=True,\n        actionable_waiting_time=True,\n        unlimited_carriers=False,\n        carrier_capacity=np.inf,\n        carrier_specs=None,\n        carrier_min_creation=1,\n        carrier_max_creation=None,\n    ):\n        super().__init__(\n            name=name,\n            position=position,\n            processing_time=processing_time,\n            processing_std=processing_std,\n        )\n        self._assert_init_args(unlimited_carriers, carrier_capacity, buffer_in)\n\n        if buffer_in is not None:\n            self._connect_to_input(buffer_in)\n        if buffer_out is not None:\n            self._connect_to_output(buffer_out)\n\n        self.buffer_in_object = buffer_in\n        self.unlimited_carriers = unlimited_carriers\n        self.carrier_capacity = carrier_capacity\n        self.waiting_time_step = waiting_time_step\n\n        self.actionable_magazin = actionable_magazin\n        self.actionable_waiting_time = actionable_waiting_time\n\n        if carrier_specs is None:\n            carrier_specs = {\"carrier\": {\"part\": {}}}\n        self.carrier_specs = carrier_specs\n\n        self.unlimited_carriers = unlimited_carriers\n        self.carrier_capacity = carrier_capacity\n        self.carrier_id = 1\n        self.carrier_min_creation = carrier_min_creation\n        self.carrier_max_creation = carrier_max_creation if carrier_max_creation is not None else 2*carrier_min_creation\n\n        self._carrier_counter = 0\n\n        self.init_waiting_time = waiting_time\n\n    def init_state(self):\n\n        self.state = ObjectStates(\n            DiscreteState('on', categories=[True, False], is_actionable=False, is_observable=False),\n            DiscreteState('mode', categories=['working', 'waiting', 'failing']),\n            DiscreteState(\n                name='waiting_time', \n                categories=np.arange(0, 100, self.waiting_time_step), \n                is_actionable=self.actionable_waiting_time,\n            ),\n            TokenState(name='carrier', is_observable=False),\n            TokenState(name='part', is_observable=False),\n            DiscreteState(\n                name='carrier_spec', \n                categories=list(self.carrier_specs.keys()), \n                is_actionable=False,\n                is_observable=True,\n            ),\n        )\n\n        self.state['waiting_time'].update(self.init_waiting_time)\n        self.state['on'].update(True)\n        self.state['mode'].update(\"waiting\")\n        self.state['carrier'].update(None)\n        self.state['part'].update(None)\n        self.state['carrier_spec'].update(list(self.carrier_specs.keys())[0])\n\n    def _assert_init_args(self, unlimited_carriers, carrier_capacity, buffer_in):\n        if unlimited_carriers:\n            if carrier_capacity &gt; 15:\n                warnings.warn(\n                    \"If carrier_capacity &gt; 15, visualization of parts\"\n                    \"on carriers is restriced and carrier will be visualized with one part\")\n            if not isinstance(carrier_capacity, int) and carrier_capacity != np.inf:\n                raise AttributeError(\"Type of carrier capacity must be int or np.inf\")\n\n    def create_carrier(self):\n\n        if self._carrier_counter == 0:\n            carrier_spec = self.random.choice(list(self.carrier_specs.keys()))\n            self.state['carrier_spec'].update(carrier_spec)\n            self._carrier_counter = self.random.randint(\n                self.carrier_min_creation, \n                self.carrier_max_creation + 1,\n            )\n\n        carrier_spec = self.state['carrier_spec'].to_str()\n\n        name = f'{self.name}_{carrier_spec}_{self.carrier_id}'\n        carrier = Carrier(\n            self.env, \n            name=name, \n            capacity=self.carrier_capacity, \n            part_specs=self.carrier_specs[carrier_spec],\n        )\n        self.carrier_id += 1\n        self._carrier_counter -= 1\n\n        return carrier\n\n    def create_parts(self, carrier):\n        \"\"\"\n        Creates the parts based on the part_specs attribute\n        For each dict in the part_specs list one part is created\n        \"\"\"\n\n        parts = []\n        for part_id, (part_name, part_spec) in enumerate(carrier.part_specs.items()):\n            part = Part(\n                env=self.env,\n                name=f\"{carrier.name}_{part_name}_{part_id}\",\n                specs=part_spec,\n            )\n            part.create(self.position)\n            parts.append(part)\n        return parts\n\n    def assemble_parts_on_carrier(self, carrier, parts):\n        \"\"\"\n        Put parts onto carrier\n        \"\"\"\n        for part in parts:\n            carrier.assemble(part)\n\n    def assemble_carrier(self, carrier):\n\n        parts = self.create_parts(carrier)\n        self.state['part'].update(parts[0].name)\n\n        processing_time = self._sample_exp_time(\n            time=self.processing_time,\n            scale=self.processing_std,\n        )\n        self.state['carrier'].update(carrier.name)\n\n        yield self.env.timeout(processing_time)\n        self.assemble_parts_on_carrier(carrier, parts)\n\n        return carrier\n\n    def wait(self):\n\n        waiting_time = self.state['waiting_time'].to_str()\n\n        if waiting_time &gt; 0:\n            yield self.env.process(self.set_to_waiting())\n            yield self.env.timeout(waiting_time)\n\n    def run(self):\n\n        while True:\n            if self.is_on():\n                yield self.env.process(self.set_to_waiting())\n                yield self.env.process(self.wait())\n\n                if self.unlimited_carriers:\n                    carrier = self.create_carrier()\n                else:\n                    carrier = yield self.env.process(self.buffer_in())\n\n                yield self.env.process(self.set_to_work())\n                carrier = yield self.env.process(self.assemble_carrier(carrier))\n\n                yield self.env.process(self.set_to_waiting())\n                yield self.env.process(self.buffer_out(carrier))\n                self.state['part'].update(None)\n                self.state['carrier'].update(None)\n\n            else:\n                yield self.turn_off()\n</code></pre>"},{"location":"api.html#lineflow.simulation.stations.Source.assemble_parts_on_carrier","title":"<code>assemble_parts_on_carrier(carrier, parts)</code>","text":"<p>Put parts onto carrier</p> Source code in <code>lineflow/simulation/stations.py</code> <pre><code>def assemble_parts_on_carrier(self, carrier, parts):\n    \"\"\"\n    Put parts onto carrier\n    \"\"\"\n    for part in parts:\n        carrier.assemble(part)\n</code></pre>"},{"location":"api.html#lineflow.simulation.stations.Source.create_parts","title":"<code>create_parts(carrier)</code>","text":"<p>Creates the parts based on the part_specs attribute For each dict in the part_specs list one part is created</p> Source code in <code>lineflow/simulation/stations.py</code> <pre><code>def create_parts(self, carrier):\n    \"\"\"\n    Creates the parts based on the part_specs attribute\n    For each dict in the part_specs list one part is created\n    \"\"\"\n\n    parts = []\n    for part_id, (part_name, part_spec) in enumerate(carrier.part_specs.items()):\n        part = Part(\n            env=self.env,\n            name=f\"{carrier.name}_{part_name}_{part_id}\",\n            specs=part_spec,\n        )\n        part.create(self.position)\n        parts.append(part)\n    return parts\n</code></pre>"},{"location":"api.html#lineflow.simulation.stations.Station","title":"<code>Station</code>","text":"<p>               Bases: <code>StationaryObject</code></p> Source code in <code>lineflow/simulation/stations.py</code> <pre><code>class Station(StationaryObject):\n\n    _width = 30\n    _height = 30\n    _color = 'black'\n\n    def __init__(\n        self,\n        name,\n        position=None,\n        processing_time=5,\n        processing_std=None,\n        rework_probability=0,\n        worker_pool=None,\n    ):\n\n        super().__init__()\n\n        if position is None:\n            position = (0, 0)\n\n        self.name = name\n        self.position = pygame.Vector2(position[0], position[1])\n\n        self.worker_pool = worker_pool\n        self.worker_requests = {}\n\n        if self.worker_pool is not None:\n            self.worker_pool.register_station(self)\n\n        self.processing_time = processing_time\n        self.rework_probability = rework_probability\n\n        if self.rework_probability &gt; 1 or self.rework_probability &lt; 0:\n            raise ValueError('rework_probability should should be between 0 and 1')\n\n        if processing_std is None:\n\n            self.processing_std = 0.1*self.processing_time\n        else:\n            assert processing_std &gt;= 0 and processing_std &lt;= 1\n            self.processing_std = processing_std*self.processing_time\n\n        self.worker_assignments = {}\n\n    @property\n    def is_automatic(self):\n        return self.worker_pool is None\n\n    @property\n    def n_workers(self):\n        if self.worker_pool is not None:\n            return len(self.worker_assignments) + 1\n        else:\n            return 1\n\n    def setup_draw(self):\n\n        self._rect = pygame.Rect(\n            self.position.x - self._width / 2,\n            self.position.y - self._height / 2,\n            self._width,\n            self._height,\n        )\n\n        font = pygame.font.SysFont(None, 20)\n        self._text = font.render(self.name, True, 'black')\n\n    def _draw(self, screen):\n        pygame.draw.rect(screen, self._color, self._rect, border_radius=5)\n        self._draw_info(screen)\n        screen.blit(\n            self._text,\n            self._text.get_rect(center=self.position + (0, -0.6 * self._height)),\n        )\n\n    def _draw_info(self, screen):\n        pass\n\n    def _draw_n_workers(self, screen):\n        if not self.is_automatic:\n            font = pygame.font.SysFont(None, 14)\n            text = font.render(\n                \"W=\" + str(self.n_workers),\n                True,\n                'black',\n            )\n            screen.blit(\n                text,\n                text.get_rect(center=self.position),\n            )\n\n    def _draw_n_carriers(self, screen):\n        font = pygame.font.SysFont(None, 14)\n        text = font.render(\n            \"C=\" + self.state['carriers_in_magazine'].to_str(),\n            True,\n            'black',\n        )\n        screen.blit(\n            text,\n            text.get_rect(center=self.position),\n        )\n\n    def get_performance_coefficient(self):\n        return compute_performance_coefficient(self.n_workers)\n\n    def _sample_exp_time(self, time=None, scale=None, rework_probability=0):\n        \"\"\"\n        Samples a time from an exponential distribution\n        \"\"\"\n\n        coeff = self.get_performance_coefficient()\n\n        t = time*coeff + self.random.exponential(scale=scale)\n\n        rework = self.random.choice(\n            [1, 2],\n            p=[1-rework_probability, rework_probability],\n        )\n\n        return t*rework\n\n    def set_to_waiting(self):\n        yield self.env.timeout(0)\n        self._color = 'yellow'\n        self.state['mode'].update('waiting')\n        yield self.env.timeout(0)\n\n    def request_workers(self):\n        \"\"\"\n        Requests (and blocks) the worker for the process coming up.\n        \"\"\"\n        if not self.is_automatic:\n            self.worker_assignments = self.worker_pool.get_worker(self.name)\n\n            self.worker_requests = {\n                name: worker.request() for name, worker in self.worker_assignments.items()\n            }\n\n            # Block workers for this process\n            for request in self.worker_requests.values():\n                yield request\n\n        else:\n            yield self.env.timeout(0)\n\n    def release_workers(self):\n        \"\"\"\n        Releases the worker, to they may follow a new assignment\n        \"\"\"\n        if not self.is_automatic:\n\n            for worker, request in self.worker_requests.items():\n                self.worker_assignments[worker].release(request)\n            self.worker_requests = {}\n            self.worker_assignments = {}\n\n    def set_to_error(self):\n        yield self.env.timeout(0)\n        self._color = 'red'\n        self.state['mode'].update('failing')\n        yield self.env.timeout(0)\n\n    def set_to_work(self):\n        yield self.env.timeout(0)\n        self._color = 'green'\n        self.state['mode'].update('working')\n        yield self.env.timeout(0)\n\n    def turn_off(self):\n        self._color = 'gray'\n        self.state['on'].update(False)\n        self.turn_off_event = simpy.Event(self.env)\n        return self.turn_off_event\n\n    def is_on(self):\n        return self.state['on'].to_str()\n\n    def turn_on(self):\n        event = self.turn_off_event\n\n        self.state['on'].update(True)\n        if not event.triggered:\n            yield event.succeed()\n        else:\n            yield self.env.timeout(0)\n\n    def connect_to_input(self, station, *args, **kwargs):\n        buffer = Buffer(name=f\"Buffer_{station.name}_to_{self.name}\", *args, **kwargs)\n        self._connect_to_input(buffer)\n        station._connect_to_output(buffer)\n\n    def connect_to_output(self, station, *args, **kwargs):\n        buffer = Buffer(name=f\"Buffer_{self.name}_to_{station.name}\", *args, **kwargs)\n        self._connect_to_output(buffer)\n        station._connect_to_input(buffer)\n\n    def _connect_to_input(self, buffer):\n        if hasattr(self, 'buffer_in'):\n            raise ValueError(f'Input of {self.name} already connected')\n        self.buffer_in = buffer.connect_to_output(self)\n\n    def _connect_to_output(self, buffer):\n        if hasattr(self, 'buffer_out'):\n            raise ValueError(f'Output of {self.name} already connected')\n        self.buffer_out = buffer.connect_to_input(self)\n\n    def register(self, env):\n        self.env = env\n        self.env.process(self.run())\n\n    def _derive_actions_from_new_state(self, state):\n        # Turn machine back on if needed\n        if not self.is_on() and 'on' in state and hasattr(self, 'turn_off_event') and state['on'] == 0:\n            self.env.process(self.turn_on())\n\n    def apply(self, actions):\n        self._derive_actions_from_new_state(actions)\n        self.state.apply(actions)\n</code></pre>"},{"location":"api.html#lineflow.simulation.stations.Station.release_workers","title":"<code>release_workers()</code>","text":"<p>Releases the worker, to they may follow a new assignment</p> Source code in <code>lineflow/simulation/stations.py</code> <pre><code>def release_workers(self):\n    \"\"\"\n    Releases the worker, to they may follow a new assignment\n    \"\"\"\n    if not self.is_automatic:\n\n        for worker, request in self.worker_requests.items():\n            self.worker_assignments[worker].release(request)\n        self.worker_requests = {}\n        self.worker_assignments = {}\n</code></pre>"},{"location":"api.html#lineflow.simulation.stations.Station.request_workers","title":"<code>request_workers()</code>","text":"<p>Requests (and blocks) the worker for the process coming up.</p> Source code in <code>lineflow/simulation/stations.py</code> <pre><code>def request_workers(self):\n    \"\"\"\n    Requests (and blocks) the worker for the process coming up.\n    \"\"\"\n    if not self.is_automatic:\n        self.worker_assignments = self.worker_pool.get_worker(self.name)\n\n        self.worker_requests = {\n            name: worker.request() for name, worker in self.worker_assignments.items()\n        }\n\n        # Block workers for this process\n        for request in self.worker_requests.values():\n            yield request\n\n    else:\n        yield self.env.timeout(0)\n</code></pre>"},{"location":"api.html#lineflow.simulation.stations.Switch","title":"<code>Switch</code>","text":"<p>               Bases: <code>Station</code></p> <p>A Switch distributes carriers onto buffer outs. In and out buffers can be provided to the constructor but can also be added to a switch using the <code>connect_to_input</code> and <code>connect_to_output</code> methods.</p> <p>Parameters:</p> Name Type Description Default <code>buffers_in</code> <code>list</code> <p>A list of buffers that lead into the Switch.</p> <code>None</code> <code>buffers_out</code> <code>list</code> <p>A list of buffers that lead away from the Switch.</p> <code>None</code> <code>position</code> <code>tuple</code> <p>X and Y position in the visualization.</p> <code>None</code> <code>alternate</code> <code>bool</code> <p>If True, the Switch switches between the buffers_out; else, only one buffer_out is used.</p> <code>False</code> Source code in <code>lineflow/simulation/stations.py</code> <pre><code>class Switch(Station):\n    \"\"\"\n    A Switch distributes carriers onto buffer outs. In and out buffers can be provided to\n    the constructor but can also be added to a switch using the `connect_to_input` and `connect_to_output`\n    methods.\n\n    Args:\n        buffers_in (list): A list of buffers that lead into the Switch.\n        buffers_out (list): A list of buffers that lead away from the Switch.\n        position (tuple): X and Y position in the visualization.\n        alternate (bool): If True, the Switch switches between the buffers_out; else, only one buffer_out is used.\n    \"\"\"\n\n    def __init__(\n        self,\n        name,\n        buffers_in=None,\n        buffers_out=None,\n        position=None,\n        processing_time=5,\n        alternate=False,\n    ):\n        super().__init__(\n            name=name,\n            position=position,\n            processing_time=processing_time,\n            # We assume switches do not have variation here\n            processing_std=0,\n        )\n\n        # time it takes for a model to change buffer_in or buffer_out\n        self.readjustment_time = 10\n\n        self.buffer_in = []\n        self.buffer_out = []\n\n        if buffers_in is not None:\n            for buffer in buffers_in:\n                self._connect_to_input(buffer)\n\n        if buffers_out is not None:\n            for buffer in buffers_out:\n                self._connect_to_output(buffer)\n\n        self.alternate = alternate\n\n    def init_state(self):\n        self.state = ObjectStates(\n            DiscreteState('on', categories=[True, False], is_actionable=False, is_observable=False),\n            DiscreteState('mode', categories=['working', 'waiting', 'failing']),\n            DiscreteState(\n                name='index_buffer_in',\n                categories=list(range(self.n_buffers_in)),\n                is_actionable=not self.alternate and self.n_buffers_in &gt; 1\n            ),\n            DiscreteState(\n                name='index_buffer_out',\n                categories=list(range(self.n_buffers_out)),\n                is_actionable=not self.alternate and self.n_buffers_out &gt; 1),\n            TokenState(name='carrier', is_observable=False),\n        )\n        self.state['index_buffer_in'].update(0)\n        self.state['index_buffer_out'].update(0)\n        self.state['on'].update(True)\n        self.state['mode'].update(\"waiting\")\n        self.state['carrier'].update(None)\n\n    @property\n    def n_buffers_in(self):\n        return len(self.buffer_in)\n\n    @property\n    def n_buffers_out(self):\n        return len(self.buffer_out)\n\n    def _get_buffer_in_position(self):\n        return self.buffer_in[\n            self.state['index_buffer_in'].value\n        ].__self__._positions_slots[-1]\n\n    def _get_buffer_out_position(self):\n        return self.buffer_out[\n            self.state['index_buffer_out'].value\n        ].__self__._positions_slots[0]\n\n    def _draw_info(self, screen):\n        pos_buffer_in = self._get_buffer_in_position()\n        pos_buffer_out = self._get_buffer_out_position()\n\n        pos_in = pos_buffer_in + 0.5*(self.position - pos_buffer_in)\n        pos_out = pos_buffer_out + 0.5*(self.position - pos_buffer_out)\n\n        pygame.draw.circle(screen, 'gray', self.position, 6)\n        for pos in [pos_in, pos_out]:\n            pygame.draw.line(screen, \"gray\", self.position, pos, width=5)\n\n    def _connect_to_input(self, buffer):\n        self.buffer_in.append(buffer.connect_to_output(self))\n\n    def _connect_to_output(self, buffer):\n        self.buffer_out.append(buffer.connect_to_input(self))\n\n    def _alternate_indices(self):\n        self.state['index_buffer_in'].set_next()\n        self.state['index_buffer_out'].set_next()\n\n    def look_in(self):\n        \"\"\"\n        Checks if part at current buffer_in is available\n        \"\"\"\n        buffer_in = self.buffer_in[self.state['index_buffer_in'].value].__self__\n        while buffer_in.get_fillstate() == 0:\n            yield self.env.timeout(1)\n            buffer_in = self.buffer_in[self.state['index_buffer_in'].value].__self__\n        return buffer_in\n\n    def look_out(self):\n        \"\"\"\n        Checks if space at current buffer_out is available\n        \"\"\"\n        buffer_out = self.buffer_out[self.state['index_buffer_out'].value].__self__\n\n        while buffer_out.get_fillstate() == 1:\n            yield self.env.timeout(1)\n            # check if buffer out changed\n            buffer_out = self.buffer_out[self.state['index_buffer_out'].value].__self__\n        return buffer_out\n\n    def get(self):\n        while True:\n            yield self.env.process(self.set_to_waiting())\n            buffer_in = yield self.env.process(self.look_in())\n            self.getting_process = None\n            yield self.env.process(self.set_to_work())\n            carrier = yield self.env.process(\n                buffer_in.get()\n            )\n            self.state['carrier'].update(carrier.name)\n            return carrier\n\n    def put(self, carrier):\n        while True:\n            yield self.env.process(self.set_to_waiting())\n            buffer_out = yield self.env.process(self.look_out())\n            yield self.env.process(buffer_out.put(carrier))\n            self.state['carrier'].update(None)\n            return\n\n    def run(self):\n        while True:\n            if self.is_on():\n                # Get carrier\n                carrier = yield self.env.process(self.get())\n\n                # Process\n                yield self.env.process(self.set_to_work())\n                yield self.env.timeout(self.processing_time)\n\n                yield self.env.process(self.put(carrier))\n\n                if self.alternate:\n                    self._alternate_indices()\n\n            else:\n                yield self.turn_off()\n</code></pre>"},{"location":"api.html#lineflow.simulation.stations.Switch.look_in","title":"<code>look_in()</code>","text":"<p>Checks if part at current buffer_in is available</p> Source code in <code>lineflow/simulation/stations.py</code> <pre><code>def look_in(self):\n    \"\"\"\n    Checks if part at current buffer_in is available\n    \"\"\"\n    buffer_in = self.buffer_in[self.state['index_buffer_in'].value].__self__\n    while buffer_in.get_fillstate() == 0:\n        yield self.env.timeout(1)\n        buffer_in = self.buffer_in[self.state['index_buffer_in'].value].__self__\n    return buffer_in\n</code></pre>"},{"location":"api.html#lineflow.simulation.stations.Switch.look_out","title":"<code>look_out()</code>","text":"<p>Checks if space at current buffer_out is available</p> Source code in <code>lineflow/simulation/stations.py</code> <pre><code>def look_out(self):\n    \"\"\"\n    Checks if space at current buffer_out is available\n    \"\"\"\n    buffer_out = self.buffer_out[self.state['index_buffer_out'].value].__self__\n\n    while buffer_out.get_fillstate() == 1:\n        yield self.env.timeout(1)\n        # check if buffer out changed\n        buffer_out = self.buffer_out[self.state['index_buffer_out'].value].__self__\n    return buffer_out\n</code></pre>"},{"location":"api.html#lineflow.simulation.stations.WorkerPool","title":"<code>WorkerPool</code>","text":"<p>               Bases: <code>StationaryObject</code></p> Source code in <code>lineflow/simulation/stations.py</code> <pre><code>class WorkerPool(StationaryObject):\n\n    def __init__(\n        self,\n        name,\n        n_workers=None,\n        transition_time=5,\n    ):\n        super().__init__()\n\n        assert n_workers is not None, \"Workers have to be set\"\n\n        self.name = name\n        self.n_workers = n_workers\n        self.transition_time = transition_time\n        self.stations = []\n        self._station_names = []\n        self._worker_names = [f\"W{i}\" for i in range(self.n_workers)]\n        self.workers = {\n            name: Worker(\n                name=name,\n                transition_time=self.transition_time\n            ) for name in self._worker_names\n        }\n\n    def register_station(self, station):\n        self.stations.append(station)\n        self._station_names.append(station.name)\n\n    def init_state(self):\n        for worker in self.workers.values():\n            worker.init_state(self.stations)\n\n        self.state = ObjectStates(\n            *[\n                worker.state for worker in self.workers.values()\n            ]\n        )\n        # Distribute worker on stations in round robin fashion\n        for worker, station in zip_cycle(self.n_workers, self.n_stations):\n            self.state[f\"W{worker}\"].apply(station)\n\n    @property\n    def n_stations(self):\n        return len(self.stations)\n\n    def register(self, env):\n        self.env = env\n\n        for worker in self.workers.values():\n            worker.register(env)\n\n        for worker_n, station in zip_cycle(self.n_workers, self.n_stations):\n\n            worker = self.workers[f\"W{worker_n}\"]\n            # Start working\n            self.env.process(worker.work())\n\n    def apply(self, actions):\n        \"\"\"\n        This should just update the state of the workers\n        \"\"\"\n        for worker, station in actions.items():\n            worker_obj = self.workers[worker]\n            self.env.process(worker_obj.assign(station))\n\n    def get_worker(self, name):\n        # gather these workers assigned to these station\n        station = self._station_names.index(name)\n        requests = {}\n\n        for worker in self.workers.values():\n            # If state of worker equals the station, the worker is blocked for exactly this station\n            if worker.state.value == station:\n                requests[worker.name] = worker\n        return requests\n</code></pre>"},{"location":"api.html#lineflow.simulation.stations.WorkerPool.apply","title":"<code>apply(actions)</code>","text":"<p>This should just update the state of the workers</p> Source code in <code>lineflow/simulation/stations.py</code> <pre><code>def apply(self, actions):\n    \"\"\"\n    This should just update the state of the workers\n    \"\"\"\n    for worker, station in actions.items():\n        worker_obj = self.workers[worker]\n        self.env.process(worker_obj.assign(station))\n</code></pre>"},{"location":"api.html#lineflow.simulation.connectors.Buffer","title":"<code>Buffer</code>","text":"<p>               Bases: <code>Connector</code></p> <p>Element that connects two different types of stations.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the station</p> required <code>capacity</code> <code>int</code> <p>Number of slots the buffer can hold</p> <code>2</code> <code>transition_time</code> <code>float</code> <p>Time carriers need to traverse the full buffer</p> <code>10</code> <code>put_time</code> <code>float</code> <p>Time the buffer needs to hand over a carrier to the next element</p> <code>1</code> <code>get_time</code> <code>float</code> <p>Time the buffer needs to get a carrier to the previous element</p> <code>1</code> Source code in <code>lineflow/simulation/connectors.py</code> <pre><code>class Buffer(Connector):\n    \"\"\"\n    Element that connects two different types of stations.\n\n    Args:\n        name (str): Name of the station\n        capacity (int): Number of slots the buffer can hold\n        transition_time (float): Time carriers need to traverse the full buffer\n        put_time (float): Time the buffer needs to hand over a carrier to the next element\n        get_time (float): Time the buffer needs to get a carrier to the previous element\n\n    \"\"\"\n\n    def __init__(self, name, capacity=2, transition_time=10, put_time=1, get_time=1, put_std=None):\n        super().__init__()\n        self.name = name\n        self.transition_time_between_slots = transition_time / (capacity - 1)\n        self.transition_time = transition_time\n        self.put_time = put_time\n        self.get_time = get_time\n        self.color = \"gray\"\n\n        # Small registry of carriers\n        self.carriers = {}\n        self.capacity = capacity\n\n        if put_std is None:\n            self.put_std = 0.1*self.put_time\n        else:\n            self.put_std = put_std\n\n        self._positions_slots = self.capacity * [None]\n        self._positions_arrow = self.capacity * [None]\n\n    def init_state(self):\n\n        self.state = ObjectStates(\n            DiscreteState('on', categories=[True, False], is_actionable=False, is_observable=False),\n            NumericState(name='fill', vmin=0, vmax=1, is_observable=True, is_actionable=False),\n        )\n\n        self.state['on'].update(True)\n        self.state['fill'].update(0)\n\n    @property\n    def n_carriers(self):\n        return len(self.carriers)\n\n    def setup_draw(self):\n\n        vec_direction = np.array(\n            [\n                self._position_output.x - self._position_input.x,\n                self._position_output.y - self._position_input.y\n            ]\n        ) / (self.capacity + 1)\n\n        if vec_direction[0] == 0 and vec_direction[1] == 0:\n            raise ValueError(f'Start and end position of {self.name} equal!')\n\n        vec_start = np.array([self._position_input.x, self._position_input.y])\n\n        for i in range(self.capacity):\n\n            pos = vec_start + (i+1)*vec_direction\n            self._positions_slots[i] = pygame.Vector2(pos[0], pos[1])\n\n        # Calculate arrowhead points\n        arrowhead_size = 3.5\n        vec_normalized = vec_direction / np.linalg.norm(vec_direction)\n\n        for i in range(self.capacity):\n            positions_arrow = vec_start + (i+1.55) * vec_direction\n            arrowhead = np.tile(positions_arrow, (3, 1))\n\n            for j, index in enumerate([0, 2]):\n                arrowhead[index] += arrowhead_size*np.array(\n                    [\n                        -vec_normalized[0]+(-1)**j*vec_normalized[1],\n                        -vec_normalized[1]-(-1)**j*vec_normalized[0],\n                    ]\n                )\n\n            self._positions_arrow[i] = arrowhead\n\n    def _draw(self, screen):\n\n        pygame.draw.line(\n            screen,\n            self.color,\n            self._position_input,\n            self._position_output,\n            width=10,\n        )\n\n        # Draw slots\n        for i, slot in enumerate(self._positions_slots):\n            pygame.draw.circle(screen, 'gray', slot, 10)\n\n        # Draw arrowheads\n        for i, arrow in enumerate(self._positions_arrow[:-1]):\n            pygame.draw.polygon(screen, 'black', arrow)\n\n        # Draw carriers\n        for carrier in self.carriers.values():\n            carrier.draw(screen)\n\n    def _sample_put_time(self):\n        return self.put_time + self.random.exponential(scale=self.put_std)\n\n    def get(self):\n        self.carrier = yield self.slots[-1].get()\n        # Release segment\n        yield self.blockers[-1].get()\n\n        # Remove carrier from registry\n        self.carriers.pop(self.carrier.name)\n        self.state['fill'].update(self.get_fillstate())\n        yield self.env.timeout(self.get_time)\n        return self.carrier\n\n    def put(self, carrier):\n\n        # Wait for segment to be released\n        yield self.blockers[0].put(1)\n\n        # Wait a bit to actually put part\n        yield self.env.timeout(self._sample_put_time())\n\n        yield self.slots[0].put(carrier)\n\n        carrier.move(self._positions_slots[0])\n\n        # Remove carrier from registry\n        self.carriers[carrier.name] = carrier\n        self.state['fill'].update(self.get_fillstate())\n\n    def get_fillstate(self):\n        return self.n_carriers/self.capacity\n\n    def _move(self, i):\n\n        slot_from = self.slots[i]\n        slot_to = self.slots[i+1]\n\n        blocker_self = self.blockers[i]\n        blocker_next = self.blockers[i+1]\n\n        while True:\n            # Wait for carrier in slot\n            carrier = yield slot_from.get()\n\n            # Waiting for segment to be free\n            yield blocker_next.put(1)\n\n            carrier.move(self._positions_slots[i+1])\n\n            # Release segment before\n            yield blocker_self.get()\n\n            # Start moving Transition\n            yield self.env.timeout(self.transition_time_between_slots)\n\n            # Push carrier to next segment\n            yield slot_to.put(carrier)\n\n    def register(self, env):\n        self.env = env\n\n        self.slots = [\n            simpy.Store(\n                env=self.env,\n                capacity=1,\n            ) for _ in range(self.capacity)\n        ]\n\n        self.blockers = [\n            simpy.Store(\n                env=self.env,\n                capacity=1,\n            ) for _ in range(self.capacity)\n        ]\n\n        for i in range(self.capacity - 1):\n            self.env.process(self._move(i))\n</code></pre>"},{"location":"api.html#lineflow.simulation.movable_objects.Carrier","title":"<code>Carrier</code>","text":"<p>               Bases: <code>MovableObject</code></p> Source code in <code>lineflow/simulation/movable_objects.py</code> <pre><code>class Carrier(MovableObject):\n\n    def __init__(self, env, name, color='Black', width=30, height=10, capacity=np.inf, part_specs=None):\n        super(Carrier, self).__init__(env, name, specs=None)\n        self.capacity = capacity\n        self._color = color\n        self._width = width\n        self._height = height\n\n        if part_specs is None:\n            part_specs = {}\n        self.part_specs = part_specs.copy()\n\n        self._width_part = 0.8*self._width\n        if capacity &lt; 15:\n            self._width_part = self._width_part / self.capacity\n\n        self._height_part = 0.7*self._height\n\n        self.parts = {}\n\n    def assemble(self, part):\n\n        if part.name in self.parts:\n            raise ValueError(f'A part with name {part.name} already contained')\n\n        if not hasattr(part, \"creation_time\"):\n            raise ValueError('Part not created')\n\n        if self.capacity == len(self.parts):\n            raise ValueError('Carrier is already full. Check your carrier_capacity')\n\n        self.parts[part.name] = part\n\n    def _draw_shape(self, screen):\n\n        self._rect = pygame.Rect(\n            self._position.x - self._width / 2,\n            self._position.y - self._height / 2,\n            self._width,\n            self._height,\n        )\n        pygame.draw.rect(screen, self._color, self._rect, border_radius=2)\n\n        for i, part in enumerate(self):\n            part._draw(\n                screen,\n                x=self._position.x+0.1*self._width - self._width / 2 + i*(self._width_part),\n                y=self._position.y - self._height_part / 2,\n                width=self._width_part,\n                height=self._height_part,\n            )\n\n    def move(self, position):\n        \"\"\"\n        \"\"\"\n\n        # If no position has been given, no move is taking place\n        if position is None:\n            return\n\n        if not isinstance(position, pygame.Vector2):\n            raise ValueError('Expect pygame vector as position')\n\n        self._position = position\n\n        for part in self.parts.values():\n            part.move(position)\n\n    def __iter__(self):\n        for part in self.parts.values():\n            yield part\n\n    def get_additional_processing_time(self, station):\n         total_time = 0\n\n         for part in self:\n             processing_time = part.specs.get(station, {}).get(\"extra_processing_time\", 0)\n             total_time += processing_time\n\n         return total_time\n</code></pre>"},{"location":"api.html#lineflow.simulation.movable_objects.Carrier.move","title":"<code>move(position)</code>","text":"Source code in <code>lineflow/simulation/movable_objects.py</code> <pre><code>def move(self, position):\n    \"\"\"\n    \"\"\"\n\n    # If no position has been given, no move is taking place\n    if position is None:\n        return\n\n    if not isinstance(position, pygame.Vector2):\n        raise ValueError('Expect pygame vector as position')\n\n    self._position = position\n\n    for part in self.parts.values():\n        part.move(position)\n</code></pre>"},{"location":"api.html#lineflow.simulation.movable_objects.Part","title":"<code>Part</code>","text":"<p>               Bases: <code>MovableObject</code></p> Source code in <code>lineflow/simulation/movable_objects.py</code> <pre><code>class Part(MovableObject):\n    def __init__(self, env, name, specs=None, color='Orange'):\n        super(Part, self).__init__(env, name, specs=specs)\n        self._color = color\n\n    def is_valid_for_assembly(self, station_name):\n        \"\"\"\n        If the part has an `assembly_condition` in its specification, then it checks whether the\n        time between its creation and now is smaller than this condition. Otherwise it will just\n        return true.\n        \"\"\"\n        if \"assembly_condition\" in self.specs.get(station_name, {}):\n            return (self.env.now - self[\"creation_time\"]) &lt; self.specs[station_name][\"assembly_condition\"]\n        else:\n            return True\n\n    def create(self, position):\n        if not isinstance(position, pygame.Vector2):\n            raise ValueError('Expect pygame vector as position')\n        self.move(position)\n\n    def _draw(self, screen, x, y, width, height):\n        _part_rect = pygame.Rect(x, y, width, height)\n        pygame.draw.rect(screen, self._color, _part_rect, border_radius=1)\n</code></pre>"},{"location":"api.html#lineflow.simulation.movable_objects.Part.is_valid_for_assembly","title":"<code>is_valid_for_assembly(station_name)</code>","text":"<p>If the part has an <code>assembly_condition</code> in its specification, then it checks whether the time between its creation and now is smaller than this condition. Otherwise it will just return true.</p> Source code in <code>lineflow/simulation/movable_objects.py</code> <pre><code>def is_valid_for_assembly(self, station_name):\n    \"\"\"\n    If the part has an `assembly_condition` in its specification, then it checks whether the\n    time between its creation and now is smaller than this condition. Otherwise it will just\n    return true.\n    \"\"\"\n    if \"assembly_condition\" in self.specs.get(station_name, {}):\n        return (self.env.now - self[\"creation_time\"]) &lt; self.specs[station_name][\"assembly_condition\"]\n    else:\n        return True\n</code></pre>"},{"location":"api.html#lineflow.simulation.movable_objects.Worker","title":"<code>Worker</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>lineflow/simulation/movable_objects.py</code> <pre><code>class Worker(object):\n    def __init__(self, name, transition_time=5):\n        self.name = name\n        self.transition_time = transition_time\n\n    def register(self, env):\n        self.env = env\n        self._working = Resource(self.env, capacity=1)\n        self.assignment = Store(env=self.env, capacity=1)\n\n    def release(self, request):\n        self._working.release(request)\n\n    def request(self):\n        return self._working.request()\n\n    def assign(self, station):\n        \"\"\"\n        Assign worker to station.\n\n        \"\"\"\n        if len(self.assignment.items) &gt; 0:\n            # Clean old assignment\n            yield self.assignment.get()\n\n        yield self.assignment.put(station)\n\n    def init_state(self, stations):\n\n        self.stations = stations\n        self.state = DiscreteState(\n            name=self.name,\n            categories=[s.name for s in self.stations],\n            is_observable=True,\n            is_actionable=True,\n        )\n\n    def work(self):\n\n        # Initially fill value of state to assignment\n        yield self.assignment.put(self.state.value)\n\n        while True:\n            # Wait for new assignment\n            station = yield self.assignment.get()\n\n            # Wait until worker is released from current station\n            transition_request = self.request()\n            yield transition_request\n\n            if self.state.value != station:\n                # New cell-assignment, wait for transition\n                # Move to new cell\n                yield self.env.timeout(self.transition_time)\n\n            self.release(transition_request)\n            # Station now can create requests\n            self.state.apply(station)\n</code></pre>"},{"location":"api.html#lineflow.simulation.movable_objects.Worker.assign","title":"<code>assign(station)</code>","text":"<p>Assign worker to station.</p> Source code in <code>lineflow/simulation/movable_objects.py</code> <pre><code>def assign(self, station):\n    \"\"\"\n    Assign worker to station.\n\n    \"\"\"\n    if len(self.assignment.items) &gt; 0:\n        # Clean old assignment\n        yield self.assignment.get()\n\n    yield self.assignment.put(station)\n</code></pre>"},{"location":"api.html#lineflow.simulation.stationary_objects.StationaryObject","title":"<code>StationaryObject</code>","text":"Source code in <code>lineflow/simulation/stationary_objects.py</code> <pre><code>class StationaryObject:\n    _objects = []\n\n    def __init__(self):\n        StationaryObject._objects.append(self)\n\n    def setup_draw(self):\n        pass\n\n    def _draw(self, screen):\n        pass\n\n    def register(self, env):\n        raise NotImplementedError\n\n    def __enter__(self):\n        # Clean up line objects\n        StationaryObject._objects = []\n\n        return self._objects\n\n    def init(self, random):\n        \"\"\"\n        Function that is called after line is built, so all available information is present\n        \"\"\"\n        self.random = random\n        self.init_state()\n\n    def init_state(self):\n        \"\"\"\n        Should initialize the state object\n        \"\"\"\n        raise NotImplementedError()\n\n    def __exit__(self, type, value, traceback):\n        StationaryObject._objects = []\n</code></pre>"},{"location":"api.html#lineflow.simulation.stationary_objects.StationaryObject.init","title":"<code>init(random)</code>","text":"<p>Function that is called after line is built, so all available information is present</p> Source code in <code>lineflow/simulation/stationary_objects.py</code> <pre><code>def init(self, random):\n    \"\"\"\n    Function that is called after line is built, so all available information is present\n    \"\"\"\n    self.random = random\n    self.init_state()\n</code></pre>"},{"location":"api.html#lineflow.simulation.stationary_objects.StationaryObject.init_state","title":"<code>init_state()</code>","text":"<p>Should initialize the state object</p> Source code in <code>lineflow/simulation/stationary_objects.py</code> <pre><code>def init_state(self):\n    \"\"\"\n    Should initialize the state object\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api.html#lineflow.simulation.environment.LineSimulation","title":"<code>LineSimulation</code>","text":"<p>               Bases: <code>Env</code></p> <p>A Gym-compatible environment for simulating production lines using LineFlow.</p> <p>This environment wraps a LineFlow production line into a reinforcement learning setup, where agents can interact with stations via actions at discrete decision points, while the underlying process unfolds in continuous time using discrete-event simulation.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>Line</code> <p>A LineFlow <code>Line</code> object representing the production line layout and behavior.</p> required <code>simulation_end</code> <code>int</code> <p>The simulation end time (in simulation time units).</p> required <code>reward</code> <code>str</code> <p>The reward signal to use. Options are \"parts\" (default) for counting produced parts, or \"uptime\" for average utilization.</p> <code>'parts'</code> <code>part_reward_lookback</code> <code>int</code> <p>Time window for computing average uptime-based rewards (used only if reward=<code>uptime</code>).</p> <code>0</code> <code>render_mode</code> <code>str or None</code> <p>Optional rendering mode. Currently supports \"human\" for visual rendering or None.</p> <code>None</code> Source code in <code>lineflow/simulation/environment.py</code> <pre><code>class LineSimulation(gym.Env):\n    \"\"\"\n    A Gym-compatible environment for simulating production lines using LineFlow.\n\n    This environment wraps a LineFlow production line into a reinforcement learning setup, where\n    agents can interact with stations via actions at discrete decision points, while the underlying\n    process unfolds in continuous time using discrete-event simulation.\n\n    Args:\n        line (lineflow.simulation.line.Line): A LineFlow `Line` object representing the production\n            line layout and behavior.\n        simulation_end (int): The simulation end time (in simulation time units).\n        reward (str, optional): The reward signal to use. Options are \"parts\" (default) for counting\n            produced parts, or \"uptime\" for average utilization.\n        part_reward_lookback (int, optional): Time window for computing average uptime-based rewards\n            (used only if reward=`uptime`).\n        render_mode (str or None, optional): Optional rendering mode. Currently supports \"human\" for\n            visual rendering or None.\n    \"\"\"\n\n    metadata = {\"render_modes\": [None, \"human\"]}\n\n    def __init__(self, line, simulation_end, reward=\"parts\", part_reward_lookback=0, render_mode=None):\n        super().__init__()\n        self.line = line\n        self.simulation_end = simulation_end\n        self.part_reward_lookback = part_reward_lookback\n\n        self.render_mode = render_mode\n\n        assert reward in [\"uptime\", \"parts\"]\n        self.reward = reward\n\n        # fix an order of states\n        self.action_space = _build_action_space(self.line.state)\n        self.observation_space = _build_observation_space(line_state=self.line.state)\n\n        self.n_parts = 0\n        self.n_scrap_parts = 0\n\n    def _map_to_action_dict(self, actions):\n\n        actions_iterator = filterfalse(\n            lambda n: not self.line.state[n[0]][n[1]].is_actionable,\n            self.line.state\n        )\n\n        actions_dict = {}\n        for action, (station, action_name) in zip(actions, actions_iterator):\n            if station not in actions_dict:\n                actions_dict[station] = {}\n\n            actions_dict[station][action_name] = action\n        return actions_dict\n\n    def step(self, actions):\n        \"\"\"\n        Advances the simulation by one environment step.\n\n        Args:\n            actions (list or array): A list of agent actions corresponding to actionable features.\n\n        Returns:\n            observation (numpy.ndarray): Observation tensor representing the current state.\n            reward (float): The computed reward for the current step.\n            terminated (bool): Whether the episode has ended.\n            truncated (bool): Whether the episode ended due to an internal error or simulation limit.\n            info (dict): Additional diagnostic information.\n        \"\"\"\n        actions = self._map_to_action_dict(actions)\n        self.line.apply(actions)\n\n        try:\n            state, terminated = self.line.step(self.simulation_end)\n            truncated = False\n        except simpy.core.EmptySchedule:\n            # TODO: not tested yet\n            state = self.line.state\n            terminated = True\n            truncated = True\n\n        observation = self._get_observations_as_tensor(state)\n\n        if self.reward == \"parts\":\n            reward = (self.line.get_n_parts_produced() - self.n_parts) - \\\n                self.line.scrap_factor*(self.line.get_n_scrap_parts() - self.n_scrap_parts)\n        elif self.reward == \"uptime\":\n            reward = self.line.get_uptime(lookback=self.part_reward_lookback).mean()\n        else:\n            assert False, f\"Reward {reward} not implemented\"\n\n        self.n_parts = self.line.get_n_parts_produced()\n        self.n_scrap_parts = self.line.get_n_scrap_parts()\n\n        if self.render_mode == \"human\":\n            self.render()\n\n        return observation, reward, terminated, truncated, self._get_info()\n\n    def _get_info(self):\n        return self.line.info()\n\n    def increase_scrap_factor(self, factor=0.1):\n        \"\"\"\n        Sets the scrap penalty factor in the reward function.\n\n        Args:\n            factor (float): The multiplier applied to scrap parts in the parts-based reward.\n        \"\"\"\n        self.line.scrap_factor = factor\n\n    def reset(self, seed=None, options=None):\n        gym.Env.reset(self, seed=seed)\n\n        self.line.reset(random_state=seed)\n        self.n_parts = 0\n        self.n_scrap_parts = 0\n\n        state, _ = self.line.step()\n        observation = self._get_observations_as_tensor(state)\n\n        if self.render_mode == \"human\":\n            self.screen = self.line.setup_draw()\n            self.render()\n        return observation, self._get_info()\n\n    @property\n    def features(self):\n        return self.line.state.observable_features\n\n    def render(self):\n        self.line._draw(self.screen)\n\n    def close(self):\n        if self.render_mode == 'human':\n            self.line.teardown_draw()\n\n    def _get_observations_as_tensor(self, state):\n\n        X = state.get_observations(lookback=1, include_time=False)\n        return np.array(X, dtype=np.float32)\n</code></pre>"},{"location":"api.html#lineflow.simulation.environment.LineSimulation.increase_scrap_factor","title":"<code>increase_scrap_factor(factor=0.1)</code>","text":"<p>Sets the scrap penalty factor in the reward function.</p> <p>Parameters:</p> Name Type Description Default <code>factor</code> <code>float</code> <p>The multiplier applied to scrap parts in the parts-based reward.</p> <code>0.1</code> Source code in <code>lineflow/simulation/environment.py</code> <pre><code>def increase_scrap_factor(self, factor=0.1):\n    \"\"\"\n    Sets the scrap penalty factor in the reward function.\n\n    Args:\n        factor (float): The multiplier applied to scrap parts in the parts-based reward.\n    \"\"\"\n    self.line.scrap_factor = factor\n</code></pre>"},{"location":"api.html#lineflow.simulation.environment.LineSimulation.step","title":"<code>step(actions)</code>","text":"<p>Advances the simulation by one environment step.</p> <p>Parameters:</p> Name Type Description Default <code>actions</code> <code>list or array</code> <p>A list of agent actions corresponding to actionable features.</p> required <p>Returns:</p> Name Type Description <code>observation</code> <code>ndarray</code> <p>Observation tensor representing the current state.</p> <code>reward</code> <code>float</code> <p>The computed reward for the current step.</p> <code>terminated</code> <code>bool</code> <p>Whether the episode has ended.</p> <code>truncated</code> <code>bool</code> <p>Whether the episode ended due to an internal error or simulation limit.</p> <code>info</code> <code>dict</code> <p>Additional diagnostic information.</p> Source code in <code>lineflow/simulation/environment.py</code> <pre><code>def step(self, actions):\n    \"\"\"\n    Advances the simulation by one environment step.\n\n    Args:\n        actions (list or array): A list of agent actions corresponding to actionable features.\n\n    Returns:\n        observation (numpy.ndarray): Observation tensor representing the current state.\n        reward (float): The computed reward for the current step.\n        terminated (bool): Whether the episode has ended.\n        truncated (bool): Whether the episode ended due to an internal error or simulation limit.\n        info (dict): Additional diagnostic information.\n    \"\"\"\n    actions = self._map_to_action_dict(actions)\n    self.line.apply(actions)\n\n    try:\n        state, terminated = self.line.step(self.simulation_end)\n        truncated = False\n    except simpy.core.EmptySchedule:\n        # TODO: not tested yet\n        state = self.line.state\n        terminated = True\n        truncated = True\n\n    observation = self._get_observations_as_tensor(state)\n\n    if self.reward == \"parts\":\n        reward = (self.line.get_n_parts_produced() - self.n_parts) - \\\n            self.line.scrap_factor*(self.line.get_n_scrap_parts() - self.n_scrap_parts)\n    elif self.reward == \"uptime\":\n        reward = self.line.get_uptime(lookback=self.part_reward_lookback).mean()\n    else:\n        assert False, f\"Reward {reward} not implemented\"\n\n    self.n_parts = self.line.get_n_parts_produced()\n    self.n_scrap_parts = self.line.get_n_scrap_parts()\n\n    if self.render_mode == \"human\":\n        self.render()\n\n    return observation, reward, terminated, truncated, self._get_info()\n</code></pre>"},{"location":"api.html#reinforcement-learning","title":"Reinforcement Learning","text":""},{"location":"api.html#scripts.train.train","title":"<code>train(config)</code>","text":"<p>Function that handles RL training</p> <p>Args: - <code>train</code>: Scores from the model update phase - <code>rollout</code>: Scores when a policy is rolled out to gather new experiences. - <code>eval</code>: Scores when a policy is evaluated on a separate environment</p> Notes <p>Size of rollout-buffer: <code>n_steps*n_envs</code>, then an model-update is done</p> Source code in <code>scripts/train.py</code> <pre><code>def train(config):\n    \"\"\"\n    Function that handles RL training\n\n    Args:\n    - `train`: Scores from the model update phase\n    - `rollout`: Scores when a policy is rolled out to gather new experiences.\n    - `eval`: Scores when a policy is evaluated on a separate environment\n\n    Notes:\n        Size of rollout-buffer: `n_steps*n_envs`, then an model-update is done\n    \"\"\"\n\n    simulation_end = config['simulation_end'] + 1\n\n    env_train = make_stacked_vec_env(\n        line=_make_line(config['env'], config['n_cells'], config['info'], curriculum=config['curriculum']),\n        simulation_end=simulation_end,\n        reward=config[\"rollout_reward\"],\n        n_envs=config['n_envs'],\n        n_stack=config['n_stack'] if not config['recurrent'] else 1,\n    )\n\n    env_eval = make_stacked_vec_env(\n        line=_make_line(config['env'], config['n_cells'], config['info'], curriculum=config['curriculum']),\n        simulation_end=simulation_end,\n        reward=config[\"eval_reward\"],\n        n_envs=1,\n        n_stack=config['n_stack'] if not config['recurrent'] else 1,\n    )\n    run = wandb.init(\n        project='Lineflow',\n        sync_tensorboard=True,\n        config=config\n    )\n    log_path = os.path.join(config['log_dir'], run.id)\n\n    if config['env'] == 'complex_line' and config['curriculum']:\n        curriculum_callback = CurriculumLearningCallback(\n            # Task marked as resolved if rewards is above 100\n            threshold=100, \n            # Update of scrap factor\n            update=(1/config[\"n_cells\"])/5, \n            factor_max=1/config[\"n_cells\"],\n            look_back=3,\n        )\n    else:\n        curriculum_callback = None\n\n    eval_callback = EvalCallback(\n        eval_env=env_eval,\n        deterministic=config['deterministic'],\n        n_eval_episodes=1,\n        # Every (eval_freq*eval_envs) / (n_steps*train_envs)  step an update is done\n        eval_freq=config[\"n_steps\"]* config[\"n_envs\"] * 10, # ever step in every env counts\n        callback_after_eval=curriculum_callback,\n    )\n\n    model_args = {\n        \"policy\": 'MlpPolicy' if not config['recurrent'] else 'MlpLstmPolicy',\n        \"env\": env_train,\n        \"n_steps\": config[\"n_steps\"],\n        \"gamma\": config['gamma'],  # discount factor\n        \"learning_rate\": config[\"learning_rate\"],\n        \"use_sde\": False,\n        \"normalize_advantage\": config['normalize_advantage'],\n        \"device\": get_device(),\n        \"tensorboard_log\": log_path,\n        \"stats_window_size\": 10,\n        \"verbose\": 0,\n        \"seed\": config['seed'] if config['seed'] != 0 else None,\n    }\n\n    if \"PPO\" in config['model']:\n        model_cls = PPO\n        model_args[\"batch_size\"] = config[\"n_steps\"]  # mini-batch size\n        model_args[\"n_epochs\"] = 5  # number of times to go over experiences with mini-batches\n        model_args[\"clip_range\"] = config['clip_range']\n        model_args[\"max_grad_norm\"] = 0.5\n        model_args[\"ent_coef\"] = config['ent_coef']\n\n        if config['recurrent']:\n            model_cls = RecurrentPPO\n\n    if \"A2C\" in config['model']:\n        model_cls = A2C\n        model_args[\"max_grad_norm\"] = 0.5\n        model_args[\"ent_coef\"] = config['ent_coef']\n\n    if \"TRPO\" in config['model']:\n        model_cls = TRPO\n\n    model = model_cls(**model_args)\n\n    model.learn(\n        total_timesteps=config[\"total_steps\"],\n        callback=CallbackList([\n            WandbCallback(verbose=0),\n            eval_callback,\n        ])\n    )\n    run.finish()\n</code></pre>"},{"location":"api.html#lineflow.learning.curriculum.CurriculumLearningCallback","title":"<code>CurriculumLearningCallback</code>","text":"<p>               Bases: <code>BaseCallback</code></p> <p>Parameters:</p> Name Type Description Default <code>look_back</code> <code>int</code> <p>Number of last evaluations that should be used to check if task is solved</p> <code>5</code> <code>factor_max</code> <code>float</code> <p>Factor with which the threshold is multiplied to get new threshold</p> <code>inf</code> Source code in <code>lineflow/learning/curriculum.py</code> <pre><code>class CurriculumLearningCallback(BaseCallback):\n    \"\"\"\n\n    Args:\n        look_back (int): Number of last evaluations that should be used to check if task is solved\n        factor_max (float): Factor with which the threshold is multiplied to get new threshold\n    \"\"\"\n    parent: EvalCallback\n\n    def __init__(self, threshold, update=0.02, factor_max=np.inf, look_back=5):\n        super().__init__(verbose=0)\n\n        self.threshold = threshold\n        self.look_back = look_back\n        self.update = update\n        self.factor = 0\n        self.factor_max = factor_max\n\n        self.rewards = []\n        self.last_adjustment = 0\n\n    def update_task(self):\n        self.factor = min(self.factor + self.update, self.factor_max)\n        self.parent.eval_env.env_method('increase_scrap_factor', (self.factor))\n        self.parent.training_env.env_method('increase_scrap_factor', (self.factor))\n\n    def _on_step(self) -&gt; bool:\n        self.rewards.append(self.parent.last_mean_reward)\n        if self.n_calls &gt;= self.last_adjustment + self.look_back:\n\n            # Check if task is solved\n            if np.mean(self.rewards[-self.look_back:]) &gt;= self.threshold:\n                self.update_task()\n                self.last_adjustment = self.n_calls\n        self.logger.record(\"eval/scrap_factor\", self.factor)\n        return True\n</code></pre>"},{"location":"examples/complex_line.html","title":"Complex line","text":"Sorry, your browser can\u2019t play this video.  <p>The Complex Line (CL) scenario combines the challenges of multiple previously explored problems into a unified setting. In this setting, components and workers must be allocated across a series of k sequential assembly stations. As in the Waiting Time (WT) scenario, an assembly condition must be maintained: if a component waits too long before being processed, it becomes invalid. In addition, the control problem includes aspects from Part Distribution (PD).</p>"},{"location":"examples/complex_line.html#what-is-optimized","title":"What is optimized?","text":"<p>In CL, the agent must learn a coordinated policy to:</p> <ul> <li>Distribute components to multiple sequential assembly stations.</li> <li>Allocate workers across these stations to balance workloads and maintain throughput.</li> <li>Ensure the assembly condition (T<sub>AC</sub>) is satisfied to avoid scrap by   control the waiting time of the source.</li> </ul> <p>The complexity arises because these tasks are interdependent: an aggressive part distribution policy can overload buffers, causing components to expire before use; on the other hand, slow part distribution delays assembly and reduces output. Similarly, suboptimal worker allocation causes bottlenecks or idle stations.</p> <p>A well-performing policy must dynamically balance these decisions to ensure a high throughput while minimizing scrap due to expired components.</p>"},{"location":"examples/complex_line.html#optimization-using-lineflow","title":"Optimization using Lineflow","text":"<p>We used Lineflow to develop and evaluate adaptive control policies for the CL scenario. RecurrentPPO performed best in this setting, achieving an average reward  of over 540. As shown in the figure below, we increased the scrap factor over the course of the training.</p> <p></p> <p>In comparison, our self implemented heuristic reached a score of 254. It uses a fixed worker allocation. The parts are distributed with a prioritization of the most empty and later buffers. The workers are distributed equally.</p>"},{"location":"examples/multi_process.html","title":"Part Distribution","text":"Sorry, your browser can\u2019t play this video.  <p>This example focuses on a specific scheduling problem in manufacturing.  Components need to be distributed across multiple parallel  processes by a single switch (SwitchD) in an optimal manner. Additionally, another  switch (SwitchF) is responsible for collecting the outputs from these processes and  sending them to a final destination. These parallel processes differ in  terms of the processing times. As a result, they need a different number of  parts distributed by the switch in order to work optimally.</p> <p>Within a given timeframe, the maximum number of parts that a process can  produce is determined by ensuring a continuous supply of components without  any interruptions. If the processing times of the source and the final destination  are negligible compared to those of the processes, the total number of parts  produced by the system is simply the sum of the parts produced by each individual  process. This provides an estimate of the maximum production capacity of the system.</p>"},{"location":"examples/multi_process.html#what-is-optimized","title":"What is optimized?","text":"<p>We optimize the distribution of the parts by the switch (SwitchD) to the stations, considering  the processing times of all processing stations. In addition, collecting the parts that  have been processed and can now be pushed to the final station at the end of the line  needs to be optimized (SwitchF). A policy implemented at both switches, that assigns  components by placing them in the least filled buffer, while prioritizing faster processes, and retrieving them from the most  filled buffer seems like the best approach for this problem. We examine the case with k=5  stations. Processing times vary with \u2211<sub>i</sub><sup>k</sup> 10+10*i + exp(0.2). The reward can be maximized by optimizing the part distribution of both switches.</p>"},{"location":"examples/multi_process.html#optimization-using-lineflow","title":"Optimization using Lineflow","text":"<p>We validated the effectiveness of Lineflow algorithms by comparing them to the rewards  achieved by the greedy approach. Our optimal agent achieved rewards up to 738, as shown  in the plot below. Only the policy based methods PPO and TRPO ensure a proper switch distribution. </p>"},{"location":"examples/multi_process.html#verification-of-the-optimization","title":"Verification of the optimization","text":"<p>As mentioned above, a greedy scheduling policy is implemented at both switches. This policy  prioritizes sending components to the least filled buffer and retrieving  components from the most filled buffer, ensuring an optimal distribution and therefore the  maximum number of parts produced.  A comparison of the component distributions between the greedy policy and the optimal  distribution for 5 parallel processing cells is given in the following figure.  For a detailed calculation and proof of the optimal part distribution, see (Link to Lineflow paper). </p>"},{"location":"examples/multi_process.html#code","title":"Code","text":"<pre><code>import numpy as np\nfrom lineflow.simulation import (\n    Line,\n    Sink,\n    Source,\n    Switch,\n    Process,\n)\n\n\ndef make_fast_only_policy(n_processes):\n    def policy(state, env):\n        return {\n            'SwitchF': {'index_buffer_in': 0, 'index_buffer_out': 0},\n            'SwitchD': {'index_buffer_in': 0, 'index_buffer_out': 0},\n        }\n    return policy\n\n\ndef make_greedy_policy(n_processes):\n    def policy(state, env):\n        # Fetch from buffer where fill is largest\n        fills_prior_process = np.array(\n            [state[f'Buffer_SwitchD_to_P{i}']['fill'].value for i in range(n_processes)]\n        )\n        fills_after_process = np.array(\n            [state[f'Buffer_P{i}_to_SwitchF']['fill'].value for i in range(n_processes)]\n        )\n        return {\n            # Fetch where fill is maximal\n            'SwitchF': {\n                'index_buffer_in': fills_after_process.argmax(),\n                },\n            # Push where fill is minimal\n            'SwitchD': {\n                'index_buffer_out': fills_prior_process.argmin()\n            },\n        }\n    return policy\n\n\nclass MultiProcess(Line):\n    \"\"\"\n    Assembly line with two sources a switch and a sink\n    \"\"\"\n\n    def __init__(self, alternate=True, n_processes=5, **kwargs):\n        self.alternate = alternate\n        self.n_processes = n_processes\n        super().__init__(**kwargs)\n\n    def build(self):\n        source = Source(\n            name='Source',\n            processing_time=2,\n            actionable_magazin=False,\n            actionable_waiting_time=False,\n            unlimited_carriers=True,\n            carrier_capacity=1,\n            position=(50, 300),\n            processing_std=0,\n        )\n\n        switch_d = Switch(\n            'SwitchD',\n            position=(200, 300),\n            alternate=self.alternate,\n            processing_time=1,\n        )\n\n        switch_f = Switch(\n            'SwitchF',\n            position=(900, 300),\n            alternate=self.alternate,\n            processing_time=1,\n        )\n\n        processes = []\n        for i in range(self.n_processes):\n            processes.append(\n                Process(\n                    name=f'P{i}',\n                    processing_time=12+10*i,\n                    position=(600, 500-100*i),\n                    processing_std=0.1,\n                )\n            )\n        sink = Sink('Sink', position=(1100, 300), processing_time=1, processing_std=0)\n        switch_f.connect_to_output(sink, capacity=2, transition_time=5)\n        switch_d.connect_to_input(source, capacity=2, transition_time=5)\n\n        for process in processes:\n            process.connect_to_input(switch_d, capacity=8, transition_time=7)\n            process.connect_to_output(switch_f, capacity=5, transition_time=7)\n\n\nif __name__ == \"__main__\":\n    n_processes = 5\n    line = MultiProcess(n_processes=n_processes, realtime=True, factor=0.1, alternate=False)\n    agent = make_greedy_policy(n_processes)\n    line.run(simulation_end=3000, agent=agent, visualize=True)\n\n    print('Number of parts produced: ', line.get_n_parts_produced())\n</code></pre>"},{"location":"examples/waiting_time.html","title":"Waiting Time","text":"Sorry, your browser can\u2019t play this video.  <p>In this scenario, the goal is to determine the optimal waiting time between  parts produced by a source station, shown in the image as S_main\u200b. This station,  along with another source S_component, supplies an assembly station, displayed  as Assembly, which combines components from both sources to produce the final  product. Once assembled, the product moves to the Sink.</p> <p>A key challenge is that components from the component source have a limited  lifespan, known as the assembly condition. If too much time passes between the  moment a component is prepared at the source and when the assembly process  begins at the assembly, the component becomes unusable. In such cases, the  assembly must discard the expired component and wait for a replacement. This  not only increases costs but also disrupts the workflow, as defective  components must be removed before the assembly can continue. This issue is  common in processes like adhesive bonding, where adhesives can dry out if  not applied within a specific timeframe.</p> <p>If the waiting time between parts is too short, the source produces excess  components that the assembly cannot process in time, leading to unnecessary  waste. Conversely, if the waiting time is too long, the assembly is left  waiting for components, delaying production. The objective is to find a  balance that ensures a steady supply of components at the assembly while  minimizing waste and inefficiencies.</p> <p>Since the assembly is assumed to be the bottleneck in the system, the overall  production rate depends on how quickly this station can receive components,  assemble them, and move the assembled product to the next buffer. The optimal  waiting time should match the pace at which the assembly and the source process  and handle parts to maintain a continuous and efficient workflow.</p>"},{"location":"examples/waiting_time.html#what-is-optimized","title":"What is optimized?","text":"<p>The processing times of the source station and the assembly station follow  specific distributions. Similarly, the time required to move a component into  and out of a buffer (put and get time) also follows distinct distributions. The  goal is to determine the optimal waiting time at the component source, which must  account for the difference between the time required by the assembly to complete  processing and the time required by source to prepare its components. Essentially,  the waiting time must bridge this gap to ensure a smooth workflow. By optimizing  the waiting time of the component source, the earned reward (i.e. produced parts)  can be maximized.</p>"},{"location":"examples/waiting_time.html#optimization-using-lineflow","title":"Optimization using Lineflow","text":"<p>We used Lineflow to optimize the production line described above. To achieve this,  we implemented A2C, PPO, Recurrent PPO, and TRPO algorithms. The maximum reward  achieved was slightly below 160, with all algorithms successfully optimizing the waiting  time and improving the reward. An explanation for the maximum reward this line can produce is given in the following paragraph. </p>"},{"location":"examples/waiting_time.html#verification-of-the-optimization","title":"Verification of the optimization","text":"<p>In this scenario, learning a fixed waiting time is sufficient to optimize production  efficiency. The image shown below illustrates how different waiting times at the  component source impact overall system performance, i.e. the reward. Using the parameters mentioned above, the optimum waiting time for the line is 18.5.  If this waiting time is chosen, the line can obtain a reward averaging nearly 160.  Therefore, all algorithms used can optimize the line sufficiently. For a detailed calculation and proof of the optimal waiting time, see (Link to Lineflow paper). </p>"},{"location":"examples/waiting_time.html#code","title":"Code","text":"<pre><code>import numpy as np\nfrom lineflow.simulation import (\n    Source,\n    Sink,\n    Line,\n    Assembly,\n)\n\n\n\ndef make_agent_fixed_waiting_time(line, waiting_time):\n    waiting_times = line['S_component'].state['waiting_time'].categories\n\n    def agent(state, env):\n        \"\"\"\n        A policy that can effectively set float waiting times by\n        alternating between ints\n        \"\"\"\n\n        index = np.argmin(np.abs(waiting_times - waiting_time))\n        actions = {}\n        actions['S_component'] = {'waiting_time': index}\n        return actions\n    return agent\n\n\ndef compute_optimal_waiting_time(line):\n    time_assembly = line['Assembly'].processing_time*1.1 + 1 + 1 + 1.1\n    time_source = line['S_component'].processing_time*1.1 + 1.1\n    return time_assembly-time_source\n\n\ndef make_optimal_agent(line):\n\n    waiting_times = line['S_component'].state['waiting_time'].categories\n    processing_time_source = line['S_component'].processing_time\n\n    def agent(state, env):\n        \"\"\"\n        A policy that can effectively set float waiting times by\n        alternating between ints\n        \"\"\"\n        time_assembly = state['Assembly']['processing_time'].value + 1 + 1 + 1.1\n        time_source = processing_time_source*1.1 + 1.1\n        waiting_time = time_assembly - time_source\n\n        index = np.argmin(np.abs(waiting_times - waiting_time))\n        actions = {}\n        actions['S_component'] = {'waiting_time': index}\n        return actions\n    return agent\n\n\nclass WTAssembly(Assembly):\n\n    def __init__(\n        self,\n        name,\n        R=0.75,\n        t_jump_max=2000,\n        **kwargs,\n    ):\n\n        self.R = R\n        self.t_jump_max = t_jump_max\n        self.trigger_time = None\n        self.factor = None\n\n        super().__init__(name=name,  **kwargs)\n\n    def init(self, random):\n        \"\"\"\n        Function that is called after line is built, so all available information is present\n        \"\"\"\n        super().init(random)\n\n        self._sample_trigger_time()\n\n    def _compute_scaling_factor(self, T_jump, E=3.1):\n\n        T = self.processing_time\n        S = self.processing_std\n        T_sim = self.t_jump_max*2\n\n        return 1/T*((T_jump*(T+S+E)) / ((self.R-1)*T_sim+T_jump) - S -E)\n\n\n    def _sample_trigger_time(self):\n\n        self.t_jump = np.random.uniform(\n            0.8*self.t_jump_max,\n            self.t_jump_max,\n        )\n\n        self.factor = self._compute_scaling_factor(self.t_jump)\n        self.trigger_time = self.random.uniform(0.25, 0.75)*self.t_jump_max\n\n    def _sample_exp_time(self, time=None, scale=None, rework_probability=0):\n        \"\"\"\n        Samples a time from an exponential distribution\n        \"\"\"\n        coeff = self.get_performance_coefficient()\n        if self.trigger_time &lt; self.env.now &lt; self.trigger_time + self.t_jump:\n            factor = self.factor\n        else: \n            factor = 1\n\n        return time*factor*coeff + self.random.exponential(scale=scale)\n\n\n\nclass WaitingTime(Line):\n    def __init__(\n        self, \n        processing_time_source=5, \n        transition_time=5, \n        with_jump=False,\n        t_jump_max=None,\n        assembly_condition=35,\n        scrap_factor=1,\n        R=0.75,\n        **kwargs,\n    ):\n        self.processing_time_source = processing_time_source\n        self.transition_time = transition_time\n        self.with_jump = with_jump\n        self.t_jump_max = t_jump_max\n        self.assembly_condition = assembly_condition\n        self.R = R\n\n        if self.with_jump:\n            assert self.t_jump_max is not None\n        super().__init__(scrap_factor=scrap_factor, **kwargs)\n\n    def build(self):\n\n        source_main = Source(\n            'S_main',\n            position=(300, 300),\n            processing_time=0,\n            carrier_capacity=2,\n            actionable_waiting_time=False,\n            unlimited_carriers=True,\n        )\n\n        source_component = Source(\n            'S_component',\n            position=(500, 450),\n            processing_time=self.processing_time_source,\n            waiting_time=0,\n            waiting_time_step=1,\n            carrier_capacity=1,\n            carrier_specs={\n                'carrier': {\"Part\": {\"Assembly\": {\"assembly_condition\": self.assembly_condition}}}\n            },\n            unlimited_carriers=True,\n            actionable_waiting_time=True,\n        )\n\n        if self.with_jump:\n            assembly = WTAssembly(\n                'Assembly',\n                t_jump_max=self.t_jump_max,\n                position=(500, 300),\n                R=self.R,\n                processing_time=20,\n                NOK_part_error_time=5,\n            )\n        else:\n            assembly = Assembly(\n                'Assembly',\n                position=(500, 300),\n                processing_time=20,\n                NOK_part_error_time=5,\n            )\n\n        sink = Sink('Sink', processing_time=0, position=(700, 300))\n\n        assembly.connect_to_component_input(\n            station=source_component,\n            capacity=3,\n            transition_time=self.transition_time,\n        )\n        assembly.connect_to_input(source_main, capacity=2, transition_time=2)\n        sink.connect_to_input(assembly, capacity=2, transition_time=2)\n\n\nif __name__ == '__main__':\n    line = WaitingTime()\n    agent = make_optimal_agent(line)\n    line.run(simulation_end=4000, agent=agent)\n    print(line.get_n_parts_produced())\n</code></pre>"},{"location":"examples/waiting_time_jump.html","title":"Waiting Time Jump","text":"Sorry, your browser can\u2019t play this video.  <p>To further explore dynamic adjustments in waiting times, we introduce a variation  called Waiting Time Jump. In this scenario, the processing time at the assembly  changes unexpectedly at a randomly selected moment within the simulation. During  a predefined time window, the processing time at the assembly increases, affecting  the overall assembly process. A visualization of these processing time variations  across multiple simulations is provided in the figure below. </p> <p>Since the exact timing and duration of these jumps T<sub>jump</sub> vary, the  maximum possible output fluctuates as well.  To ensure fair comparisons between agents, we construct the  new assembly time based on T<sub>jump</sub>,\u200b so that the maximum possible reward  remains constant. Specifically, we define a constant value R between 0.5 and 1.0  and set a factor f so that the expected maximum number of produced parts is R\u22c5N,  where N is the expected number of parts produced in the standard waiting time  scenario without jumps.  For a detailed explanation and proof, see (Link to Lineflow paper).</p>"},{"location":"examples/waiting_time_jump.html#what-is-optimized","title":"What is optimized?","text":"<p>A well-designed control strategy must adapt to these changes in real time.  When the processing time changes, the agent only becomes aware of  it after the first part is completed under the new conditions. When the processing  time at the assembly suddenly increases, the system may initially  continue operating with an outdated waiting time, resulting in expired components.  Similarly, when the processing time decreases, the waiting time may be too long,  causing unnecessary delays. The challenge for an adaptive control agent is to detect  these changes as early as possible and adjust the waiting time accordingly. If these changes to the assembly time are taken into account as quickly as possible,  the waiting time can be optimized so that the reward is maximized.</p>"},{"location":"examples/waiting_time_jump.html#optimization-using-lineflow","title":"Optimization using Lineflow","text":"<p>Our line can achieve a maximum reward of 115, with the RecurrentPPO algorithm  performing best. This method achieves an average reward of up to 106. The A2C  algorithm achieves an average reward of over 100, although the other methods do not  reach these results. </p>"},{"location":"examples/waiting_time_jump.html#verification-of-the-optimization","title":"Verification of the optimization","text":"<p>To assess the effectiveness of different control strategies, we evaluate how well  an agent can learn and adapt to these shifts based on observed processing times.  By continuously updating its estimates of how long assembly takes, the agent can  optimize waiting times to maintain a stable and efficient production flow.</p> <p>To develop an optimal strategy for WTJ, we estimate the processing time based on  past observations. Specifically, we track the processing times reported from  the assembly station and compute a rolling average over recent observations.  A longer tracking period provides a more stable estimate but slows the agent\u2019s  ability to detect sudden jumps.</p> <p>By testing different tracking periods, we found that using only the most recent  observation allows the agent to respond the fastest, leading to the highest reward, as shown in the figure below. This optimized performance is used as the maximum possible reward (115) for our line. </p>"},{"location":"examples/waiting_time_jump.html#code","title":"Code","text":"<pre><code>import numpy as np\nfrom lineflow.simulation import (\n    Source,\n    Sink,\n    Line,\n    Assembly,\n)\n\n\n\ndef make_agent_fixed_waiting_time(line, waiting_time):\n    waiting_times = line['S_component'].state['waiting_time'].categories\n\n    def agent(state, env):\n        \"\"\"\n        A policy that can effectively set float waiting times by\n        alternating between ints\n        \"\"\"\n\n        index = np.argmin(np.abs(waiting_times - waiting_time))\n        actions = {}\n        actions['S_component'] = {'waiting_time': index}\n        return actions\n    return agent\n\n\ndef compute_optimal_waiting_time(line):\n    time_assembly = line['Assembly'].processing_time*1.1 + 1 + 1 + 1.1\n    time_source = line['S_component'].processing_time*1.1 + 1.1\n    return time_assembly-time_source\n\n\ndef make_optimal_agent(line):\n\n    waiting_times = line['S_component'].state['waiting_time'].categories\n    processing_time_source = line['S_component'].processing_time\n\n    def agent(state, env):\n        \"\"\"\n        A policy that can effectively set float waiting times by\n        alternating between ints\n        \"\"\"\n        time_assembly = state['Assembly']['processing_time'].value + 1 + 1 + 1.1\n        time_source = processing_time_source*1.1 + 1.1\n        waiting_time = time_assembly - time_source\n\n        index = np.argmin(np.abs(waiting_times - waiting_time))\n        actions = {}\n        actions['S_component'] = {'waiting_time': index}\n        return actions\n    return agent\n\n\nclass WTAssembly(Assembly):\n\n    def __init__(\n        self,\n        name,\n        R=0.75,\n        t_jump_max=2000,\n        **kwargs,\n    ):\n\n        self.R = R\n        self.t_jump_max = t_jump_max\n        self.trigger_time = None\n        self.factor = None\n\n        super().__init__(name=name,  **kwargs)\n\n    def init(self, random):\n        \"\"\"\n        Function that is called after line is built, so all available information is present\n        \"\"\"\n        super().init(random)\n\n        self._sample_trigger_time()\n\n    def _compute_scaling_factor(self, T_jump, E=3.1):\n\n        T = self.processing_time\n        S = self.processing_std\n        T_sim = self.t_jump_max*2\n\n        return 1/T*((T_jump*(T+S+E)) / ((self.R-1)*T_sim+T_jump) - S -E)\n\n\n    def _sample_trigger_time(self):\n\n        self.t_jump = np.random.uniform(\n            0.8*self.t_jump_max,\n            self.t_jump_max,\n        )\n\n        self.factor = self._compute_scaling_factor(self.t_jump)\n        self.trigger_time = self.random.uniform(0.25, 0.75)*self.t_jump_max\n\n    def _sample_exp_time(self, time=None, scale=None, rework_probability=0):\n        \"\"\"\n        Samples a time from an exponential distribution\n        \"\"\"\n        coeff = self.get_performance_coefficient()\n        if self.trigger_time &lt; self.env.now &lt; self.trigger_time + self.t_jump:\n            factor = self.factor\n        else: \n            factor = 1\n\n        return time*factor*coeff + self.random.exponential(scale=scale)\n\n\n\nclass WaitingTime(Line):\n    def __init__(\n        self, \n        processing_time_source=5, \n        transition_time=5, \n        with_jump=False,\n        t_jump_max=None,\n        assembly_condition=35,\n        scrap_factor=1,\n        R=0.75,\n        **kwargs,\n    ):\n        self.processing_time_source = processing_time_source\n        self.transition_time = transition_time\n        self.with_jump = with_jump\n        self.t_jump_max = t_jump_max\n        self.assembly_condition = assembly_condition\n        self.R = R\n\n        if self.with_jump:\n            assert self.t_jump_max is not None\n        super().__init__(scrap_factor=scrap_factor, **kwargs)\n\n    def build(self):\n\n        source_main = Source(\n            'S_main',\n            position=(300, 300),\n            processing_time=0,\n            carrier_capacity=2,\n            actionable_waiting_time=False,\n            unlimited_carriers=True,\n        )\n\n        source_component = Source(\n            'S_component',\n            position=(500, 450),\n            processing_time=self.processing_time_source,\n            waiting_time=0,\n            waiting_time_step=1,\n            carrier_capacity=1,\n            carrier_specs={\n                'carrier': {\"Part\": {\"Assembly\": {\"assembly_condition\": self.assembly_condition}}}\n            },\n            unlimited_carriers=True,\n            actionable_waiting_time=True,\n        )\n\n        if self.with_jump:\n            assembly = WTAssembly(\n                'Assembly',\n                t_jump_max=self.t_jump_max,\n                position=(500, 300),\n                R=self.R,\n                processing_time=20,\n                NOK_part_error_time=5,\n            )\n        else:\n            assembly = Assembly(\n                'Assembly',\n                position=(500, 300),\n                processing_time=20,\n                NOK_part_error_time=5,\n            )\n\n        sink = Sink('Sink', processing_time=0, position=(700, 300))\n\n        assembly.connect_to_component_input(\n            station=source_component,\n            capacity=3,\n            transition_time=self.transition_time,\n        )\n        assembly.connect_to_input(source_main, capacity=2, transition_time=2)\n        sink.connect_to_input(assembly, capacity=2, transition_time=2)\n\n\nif __name__ == '__main__':\n    line = WaitingTime()\n    agent = make_optimal_agent(line)\n    line.run(simulation_end=4000, agent=agent)\n    print(line.get_n_parts_produced())\n</code></pre>"},{"location":"examples/worker_assignment.html","title":"Worker Assignment","text":"Sorry, your browser can\u2019t play this video.  <p>In many production lines, manual tasks can be completed more efficiently  when multiple workers collaborate. This example seeks to identify the optimal  distribution of a limited workforce across various stations, each with different  processing times. In addition, it is assumed that the processing time at each station depends on the number of workers assigned. In our experiments, adding one more worker reduces  the processing time by approximately 74%.</p>"},{"location":"examples/worker_assignment.html#what-is-optimized","title":"What is optimized?","text":"<p>The stations are linked by buffers, and the overall production speed is determined  by the slowest station. Therefore, the goal is to allocate workers in such a  way that the maximum processing time across all stations is minimized.  This allocation process is constrained by factors such as delays caused by the  movement of workers between stations. If workers are assigned in a way that maximizes  the production time of the slowest station, the expected reward is also maximized.</p>"},{"location":"examples/worker_assignment.html#optimization-using-lineflow","title":"Optimization using Lineflow","text":"<p>We can get the best results by using the actor-critic method A2C with an averaged reward of  278, surpassing all other methods and roughly reaching the reward optimum of 287.  </p>"},{"location":"examples/worker_assignment.html#verification-of-the-optimization","title":"Verification of the optimization","text":"<p>We compare the results given by LineFlow with the theoretical optimal solution in  the following paragraph. This problem can be framed as an optimization challenge, where the objective is  to minimize the maximum processing time by determining the optimal worker  distribution across stations. This requires solving a max-min problem, which is  computationally complex due to its inherent difficulty and the need for integer  partitioning. Additionally, finding the best distribution in a dynamic environment  is even more challenging, as it involves accurately estimating the parameters for  each station. To check the worker distribution calculated by LineFlow, all possible  worker allocations are listed to evaluate them empirically. As mentioned above, the line can reach a reward of 287 with the optimal worker allocation. For a detailed calculation of the worker assignment, see (Link to Lineflow paper).</p> <p></p>"},{"location":"examples/worker_assignment.html#code","title":"Code","text":"<pre><code>import numpy as np\nfrom lineflow.simulation import (\n    Line,\n    Sink,\n    Source,\n    Assembly,\n    Magazine,\n    Switch,\n    Process,\n    WorkerPool,\n)\n\n\ndef make_random_agent(n_assemblies):\n    n_workers = n_assemblies * 3\n\n    def shuffle_workers(state, env):\n        \"\"\"\n        Shuffles every few seconds the workers\n        \"\"\"\n        worker_names = [a.name for a in state.get_actions()[\"Pool\"]]\n\n        assignments = np.random.randint(n_assemblies, size=n_workers)\n\n        return {\n            'Pool': dict(zip(worker_names, assignments))\n        }\n    return shuffle_workers\n\n\nclass WorkerAssignment(Line):\n    '''\n    Assembly line with two assembly stations served by a component source\n    '''\n    def __init__(self, n_assemblies=8, n_carriers=20, with_rework=False, *args, **kwargs):\n        self.with_rework = with_rework\n        self.n_carriers = n_carriers\n        self.n_assemblies = n_assemblies\n\n        super().__init__(*args, **kwargs)\n\n    def build(self):\n\n        magazine = Magazine(\n            'Setup',\n            unlimited_carriers=False,\n            carriers_in_magazine=self.n_carriers,\n            position=(50, 100),\n            carrier_capacity=self.n_assemblies,\n            actionable_magazine=False,\n        )\n\n        pool = WorkerPool(name='Pool', n_workers=3*self.n_assemblies)\n\n        sink = Sink(\n            'EOL',\n            position=(self.n_assemblies*100-50, 100),\n            processing_time=4\n        )\n\n        sink.connect_to_output(magazine, capacity=6)\n\n        # Create assemblies\n        assemblies = []\n        for i in range(self.n_assemblies):\n            a = Assembly(\n                f'A{i}',\n                position=((i+1)*100-50, 300),\n                processing_time=16+4*i,\n                worker_pool=pool,\n            )\n\n            s = Source(\n                f'SA{i}',\n                position=((i+1)*100-50, 450),\n                processing_time=2,\n                unlimited_carriers=True,\n                carrier_capacity=1,\n                actionable_waiting_time=False,\n            )\n\n            a.connect_to_component_input(s, capacity=2, transition_time=4)\n            assemblies.append(a)\n        # connect assemblies\n        magazine.connect_to_output(assemblies[0], capacity=4, transition_time=10)\n        for a_prior, a_after in zip(assemblies[:-1], assemblies[1:]):\n            a_prior.connect_to_output(a_after, capacity=2, transition_time=10)\n\n        if self.with_rework:\n\n            rework_switch = Switch(\"ReworkStart\", alternate=True, position=(750, 300))\n            rework_switch.connect_to_input(assemblies[-1], capacity=2, transition_time=10)\n\n            distribute_switch = Switch(\"Distribute\", alternate=True, position=(900, 400))\n            distribute_switch.connect_to_input(rework_switch)\n\n            collect_switch = Switch(\"Collect\", alternate=True, position=(900, 100))\n\n            for i in range(3):\n                p = Process(f'R{i+1}', position=(850+i*50, 250))\n                p.connect_to_input(distribute_switch, capacity=2, transition_time=2)\n                p.connect_to_output(collect_switch, capacity=2, transition_time=2)\n\n            rework_end_switch = Switch(\"ReworkEnd\", alternate=True, position=(750, 200))\n            rework_end_switch.connect_to_input(rework_switch, capacity=2, transition_time=2)\n            rework_end_switch.connect_to_input(collect_switch, capacity=2, transition_time=2)\n            rework_end_switch.connect_to_output(sink, capacity=2, transition_time=2)\n        else:\n            assemblies[-1].connect_to_output(sink, capacity=4)\n\n\nif __name__ == '__main__':\n    line = WorkerAssignment(with_rework=True, realtime=False, n_assemblies=7, step_size=2)\n\n    agent = make_random_agent(7)\n    line.run(simulation_end=1000, agent=agent, visualize=True, capture_screen=True)\n    print(line.get_n_parts_produced())\n</code></pre>"},{"location":"userguide/core_concepts.html","title":"Core Concepts","text":"<p>A production line in LineFlow consists of a number of line objects that are put together to form the line.</p>"},{"location":"userguide/core_concepts.html#line-objects","title":"Line Objects","text":"<p>These are the building blocks to set up assembly lines.</p> Name Visualization Type Description <code>Process</code> stationary A station that simulates a processing step on the Part. The processing step can be set to repeat due to a simulated human error, which doubles the processing time. <code>Sink</code> stationary Removes components from a <code>Carrier</code>. Carriers arrived here are marked as OK. Empty carriers are either removed or returned to a <code>Magazine</code> or <code>Source</code> using a separate out-buffer depending on the layout. This way, the station can be used in both linear and circular lines. <code>Source</code> stationary Places parts onto carriers. Can set individual  properties, called part spec, to every part set up, like the assembly condition. Carriers are either created, taken from a <code>Magazine</code>, or fetched from a separate incoming buffer. <code>Assembly</code> stationary A Station for simulating assembly activities on the line.Individual parts and components are delivered with individual carriers, assembled with a simulated processing time, and forwarded to the downstream station. Can be connected to a <code>WorkerPool</code> that can assign worker objects to it, modifying its processing time. <code>WorkerPool</code> stationary Holds a predefined set of <code>Worker</code> objectsand is attached to a fixed number of stations. Multiple pools can coexist for an assembly line,allowing modeling of different skills or experience of workers. <code>Magazine</code> stationary Magazine station is used to manage the carriers.The total number of carriers available to the line can be controlled via this station. The capacity of the carriers, i.e., the possible number of components that can be added at the assembly station, is also determined by this station.If the number of carriers is not of interest, the source can place the parts directly on carriers, and no magazine is required. <code>Switch</code> stationary The Switch distributes carriers to different stations,enabling parallel structures within the line. <code>Buffer</code> stationary The Buffer transports carriers from one station to another. Time needed to push and get carriers to and from can be specified as well as its capacity and the time a <code>Carrier</code> needs to traverse the buffer. <code>Carrier</code> movable Is set up at a <code>Source</code> station or a <code>Magazine</code>and holds a predefined number of <code>Part</code> objects. <code>Part</code> movable Single unit which is initially created at a <code>Source</code>.Holds a part spec each station handling it can accessand individually adapt to. <code>Worker</code> movable Belongs to a <code>WorkerPool</code> and can be assigned to a station. Traversal time can be configured."},{"location":"userguide/core_concepts.html#states","title":"States","text":"<p>In <code>LineFlow</code>, the <code>LineStates</code> represent the current state of an assembly line and thus is the key interface to extract information from it, like when optimizing reinforcement learning agents. On the one hand, different line objects can constantly update their state (like setting a status or tracking a part) which in turn can be observed. On the other hand, the policy can apply changes to a certain state to actively change the behavior of an object.</p>"},{"location":"userguide/core_concepts.html#types","title":"Types","text":"<p>As different states need different encodings as observations and different probabilistic modelings as actions, we have to distinguish different types of states. Currently, the following types of are provided:</p> <ul> <li><code>DiscreteState</code>: State that handles     discrete objects that do not have a natural order, like     categories, where the available choices are clear from the     beginning (i.e, the possible modes of a station)</li> <li><code>NumericState</code>: State that handles     numeric values</li> <li><code>CountState</code>: State to count objects     or occurences, like carriers, produced parts, scrap, workers</li> <li><code>TokenState</code>:  State to handle     discrete objects where its not clear from the start which and how     many objects need to be tracked (i.e, the ID of a carrier visiting     the station).</li> </ul>"},{"location":"userguide/core_concepts.html#mechanics","title":"Mechanics","text":"<p>Typically, the user must not initialize states by herself as this is done in the respective <code>LineStates</code>, like stations or buffers. The following explanations serve developers that intend to implement own line objects.</p>"},{"location":"userguide/core_concepts.html#properties","title":"Properties","text":"<p>For each state, it must be decided whether it can be observed, i.e. is visible to a policy, and is actionable, i.e. can be changed by a policy. These properties need to be set when initializing the state  and cannot be changed afterwards.  </p> <p>For instance, the mode of a station can be observed, but the policy can not actively change the state as this depends on exterior effects:</p> <pre><code>from lineflow.simulation.states import DiscreteState\n\nmode = DiscreteState(\n    name='mode', \n    categories=['waiting', 'working', 'error'], \n    is_actionable=False,\n    is_observable=True,\n)\n\npower = DiscreteState(\n    name='power', \n    categories=['on', 'off'], \n    is_actionable=True,\n    is_observable=True,\n)\n</code></pre> <p>Counts, on the other hand, may be initialized as follows:</p> <pre><code>from lineflow.simulation.states import CountState\n\ncount = CountState(\n    name='n_scraps', \n    is_actionable=False,\n    is_observable=True,\n)\n</code></pre>"},{"location":"userguide/core_concepts.html#change-values","title":"Change values","text":"<p>Generally, there are two situations where a value of a state needs to be updated during a simulation: Either external properties change and the state needs to be synchronized by a <code>LineState</code> or a policy actively wants to change a value. Both ways are explained in the following.</p>"},{"location":"userguide/core_concepts.html#updating-from-a-line-object","title":"Updating from a line object:","text":"<p>When a line object needs to update a status, the <code>update</code> method has to be called:</p> <pre><code>mode.update('waiting')\npower.update('off')\ncount.update(0)\ncount.increment()\n</code></pre>"},{"location":"userguide/core_concepts.html#updating-from-an-agent","title":"Updating from an agent","text":"<p>When a policy wants to change a state, the  <code>apply</code> method needs to be called. In case of discrete events, the input now is not the string representation but the encoded one. For instance:</p> <pre><code>mode.apply(0)   # set to waiting\nmode.apply(1)   # set to working\nmode.apply(2)   # set to failing\n</code></pre>"},{"location":"userguide/core_concepts.html#access-values","title":"Access values","text":"<p>Values of a state can be accessed using the attribute <code>value</code>:</p> <pre><code>mode.update('waiting')\nmode.value             # Gives 0\nmode.to_str()          # Gives 'waiting'\n</code></pre>"},{"location":"userguide/core_concepts.html#states-of-line-objects","title":"States of line objects","text":"<p>Multiple states can be gathered in a <code>ObjectStates</code>. These reflect all states of a <code>LineStates</code></p> <p><pre><code>states = ObjectStates(\n    DiscreteState('mode', categories=['waiting', 'working', 'error']),\n    DiscreteState('on', categories=[True, False]),\n    CountState('n_scraps',  is_actionable=False, is_observable=True),\n)\n</code></pre> From there, the underlying states can be accessed individually using a dict-like fashion as follows:</p> <pre><code>states['mode'].update('waiting')\nstates['on'].update(True)\nstates['n_scraps'].increment()\n</code></pre> <p>Alternatively, all states can be updated with a single call of <code>update</code>:</p> <pre><code>states.update(\n    {\n        'mode': 'waiting',\n        'on': True,\n        'n_scraps': 7,\n    }\n)\n</code></pre> <p>The values can be accessed all together via the <code>value</code> attribute:</p> <pre><code>print(states.values)  # prints [0, 0, 7]\n</code></pre>"},{"location":"userguide/core_concepts.html#states-of-lines","title":"States of lines","text":"<p>A <code>Line</code> object consists of multiple <code>ObjectStates</code> elements of all objects attached to it. Once a single state of an object is updated, this is directly visible in the state of the line.</p>"},{"location":"userguide/core_concepts.html#parts-and-carriers","title":"Parts and Carriers","text":"<p>In <code>LineFlow</code>, every part is transported by a carrier as it moves through the production line. Hence, carriers act as mobile containers: once a <code>Source</code> (or a <code>Magazine</code>) creates a new carrier, it puts a predefined sequence of initial parts onto the newly created carrier. At each station the carrier visits, new parts can be added or existing parts removed, typically at <code>Assembly</code> stations.</p> <p>Parts can show different behaviors at different stations. For instance, a certain part may require an additional processing time at a given process or has to statisfy a certain condition before it can be assembled. These specification are fixed when creating the part at the source and can be given in a <code>carrier_spec</code>. For instance, the following parameter can be given when creating a source station:</p> <pre><code>carrier_spec = {\n    \"CarrierA\": {\n        \"Part1\": {\n            \"P1\": {\"extra_processing_time\": 5},\n            \"A1\": {\"assembly_condition\": 10},\n        }\n        \"Part2\": {\n            \"P1\": {\"extra_processing_time\": 1},\n            \"P2\": {\"extra_processing_time\": 3},\n            \"A1\": {\"assembly_condition\": 8},\n        }\n    },\n    \"CarrierB\": {\n        \"Part1\": {\n            \"A1\": {\"assembly_condition\": 10},\n        }\n        \"Part2\": {\n            \"P2\": {\"extra_processing_time\": 3},\n        }\n        \"Part3\": {\n            \"P1\": {\"extra_processing_time\": 1},\n            \"P2\": {\"extra_processing_time\": 3},\n            \"A1\": {\"assembly_condition\": 8},\n        }\n    }\n}\n</code></pre> <p>Here, the source creates (randomly) either a carrier of type <code>CarrierA</code> or of <code>CarrierB</code>. <code>CarrierA</code> has two parts, <code>Part1</code> and <code>Part2</code>, each with their own specifications. For instance, <code>Part1</code> consues an additional processing time of 5 time stepts at station <code>P1</code> and needs to be assembled at station <code>A1</code> within <code>10</code> time steps from its creation. Similarly, <code>Part2</code> has a processing time of 1 at <code>P1</code>, 3 at <code>P2</code>, and an assembly condition of 8 at <code>A1</code>.</p>"},{"location":"userguide/customization.html","title":"Introduction","text":"<p>To introduce a new station in the simulation environment, a new class should be created that extends the <code>Station</code> class. The new station must define its own behavior by providing implementations of the <code>run()</code> and <code>init_state()</code> method. For instance, suppose we want to implement a simple Inspection Station that evaluates carriers and flags defective ones. This can be achieved by defining a class that inherits from <code>Station</code>:</p> <pre><code>class Inspection(Station):\n    def __init__(self, name, buffer_in=None, buffer_out=None, position=None, defect_probability=0.1):\n        super().__init__(\n            name=name,\n            position=position,\n        )\n        self.defect_probability = defect_probability\n\n        if buffer_in is not None:\n            self._connect_to_input(buffer_in)\n        if buffer_out is not None:\n            self._connect_to_output(buffer_out)\n\n    def init_state(self):\n        self.state = ObjectStates(\n            DiscreteState('on', categories=[True, False], is_actionable=False, is_observable=False),\n            DiscreteState('mode', categories=['working', 'waiting', 'failing']),\n            TokenState(name='carrier', is_observable=False),\n            CountState('defective_parts', is_actionable=False, is_observable=True, vmin=0),\n        )\n        self.state['on'].update(True)\n        self.state['mode'].update(\"waiting\")\n        self.state['carrier'].update(None)\n        self.state['defective_parts'].update(0)\n\n    def run(self):\n        while True:\n            if self.is_on():\n                # wait for carrier\n                yield self.env.process(self.set_to_waiting())\n                carrier = yield self.env.process(self.buffer_in())\n                self.state['carrier'].update(carrier.name)\n\n                # process part\n                yield self.env.process(self.set_to_work())\n                self.state['mode'].update('working')\n                yield self.env.timeout(self.processing_time)\n\n                if self.random.uniform(0, 1) &lt; self.defect_probability:\n                    # handle defective part\n                    self.state['defective_parts'].increment()\n                    yield self.env.timeout(2)\n                    self.state['mode'].update('waiting')\n\n                # push carrier on buffer out\n                yield self.env.process(self.buffer_out(carrier))\n                self.state['carrier'].update(None)\n            else:\n                yield self.turn_off()\n</code></pre>"},{"location":"userguide/quickstart.html","title":"Quick Start","text":"<p>You can define a Line class as follows.</p> <pre><code>from lineflow.simulation import Line, Source, Sink, Buffer\n\nclass SimpleLine(Line):\n\n    def build(self):\n\n        # Configure a simple line\n        buffer = Buffer('Buffer', capacity=6)\n\n        Source(\n            name='Source',\n            processing_time=5,\n            unlimited_carriers=True,\n            buffer_out=buffer,\n            position=(100, 300),\n        )\n\n        Sink('Sink', buffer_in=buffer, position=(600, 300))\n</code></pre> <p>or alternatively:</p> <pre><code>from lineflow.simulation import Line, Source, Sink\n\nclass SimpleLine(Line):\n\n    def build(self):\n        source = Source(name='Source', processing_time=5, position=(100, 300), unlimited_carriers=True)\n        sink = Sink('Sink', position=(600, 300))\n        source.connect_to_output(station=sink, capacity=6)\n</code></pre> <p>Instantiate your line with:</p> <pre><code>line = SimpleLine(realtime=True)\n</code></pre> <p>Run line simulation. The run function also takes a policy as an argument, see Reinforcement Learning.</p> <pre><code>line.run(simulation_end=4000, visualize=True)\n</code></pre> <p>Analyze the simulation data in form of a dataframe of features over time. <pre><code>simulation_data = line.state.df()\n</code></pre></p> <p>See the examples for more complex scenarios.</p>"},{"location":"userguide/rl.html","title":"Optimization using LineLlow","text":"<p>Reinforcement Learning (RL) provides a powerful paradigm for learning control policies through trial-and-error interactions with a simulated environment. In the context of LineFlow, RL agents observe the current state of a production line, select control actions and receive feedback in the form of performance\u2010based rewards. Over many episodes, agents learn to optimize throughput, minimize scrap, and adapt to stochastic disturbances without hand-crafting rule\u2010based strategies. </p> <p>This chapter explains how observation and action spaces are defined and how to train RL agents on custom production line setups. Note that once a production line is implemented in LineFlow, it can easily wrapped into a <code>gymnasium</code> environment. Please also have a look into <code>train.py</code> how models may be trained and validated using  <code>stable_baselines3</code>.</p>"},{"location":"userguide/rl.html#observation-space","title":"Observation Space","text":"<p>In RL, the observation space defines what the piece of information the agent sees at each interaction step. It is therefore a subset of the <code>LineState</code>. In LineFlow, all states marked <code>is_observable=True</code> in your line\u2019s <code>LineStates</code> are automatically aggregated into a flat observation vector. Common observable features include:</p> <ul> <li>Buffer fill levels (normalized counts of carriers in each buffer) Station modes (waiting, working, failing)</li> <li>Processing times of the last completed tasks</li> <li>Worker assignments (how many workers are currently at each station)</li> </ul> <p>By default, LineFlow normalizes numeric values (e.g. fill levels to [0,1]), encodes discrete categories as integers, and excludes unobservable or lagged states. You can customize which states appear in the observation space by toggling the is_observable flag when you construct each DiscreteState, NumericState, etc.</p>"},{"location":"userguide/rl.html#action-space","title":"Action Space","text":"<p>The action space specifies what decisions the agent can enact at each step. In LineFlow, any state flagged <code>is_actionable=True</code> becomes part of the action vector. Typical actionable controls include:</p> <ul> <li>Setting waiting times at Source stations (numeric)</li> <li>Routing choices at Switch stations (selecting an outgoing buffer index)</li> <li>Worker assignments (which station each worker in a WorkerPool should serve)</li> <li>On/off or mode changes for switches or machines</li> </ul> <p>LineFlow enforces bounds on each action (e.g. allowed waiting-time ranges, valid buffer indices) and will raise an error if the agent proposes out-of-range values.</p>"},{"location":"userguide/rl.html#environment","title":"Environment","text":"<p><code>LineSimulation</code> is a wrapper around a LineFlow simulation that makes it compatible with Gymnasium's Env interface. It allows you to treat a LineFlow production line as a Gym environment, providing action_space, observation_space, and core methods step, reset, render, and close.</p>"},{"location":"userguide/rl.html#initialization","title":"Initialization","text":"<pre><code>from lineflow.simulation import LineSimulation\n\n# wrap your custom line into a Gym environment\nenv = LineSimulation(\n    line=MyNewLine(),                # your LineFlow scenario instance\n    simulation_end=4000,             # simulation time horizon per episode\n    reward='parts',                  # choose 'parts' or 'uptime'\n    part_reward_lookback=0,          # window for uptime averaging if reward='uptime'\n    render_mode=None,                # 'human' to enable interactive rendering\n)\n</code></pre>"},{"location":"userguide/rl.html#step","title":"<code>step()</code>","text":"<p><pre><code>observation, reward, terminated, truncated, self._get_info() = env.step(actions)\n</code></pre> The step function is the core function of a LineSimulation, it performs one step by:</p> <ul> <li>Applying the actions of the Agent</li> <li>Running one simulation step</li> <li>Reciving the the state that was possibly influenced by the applied actions</li> <li>Calculating the reward</li> </ul> <p>The two implemented <code>reward</code> calculations are:</p> <ul> <li>Parts reward (<code>reward='parts'</code>): Net new parts produced minus scrap since the last step, with scrap penalized by <code>line.scrap_factor</code>.</li> <li>Uptime reward (<code>reward='uptime'</code>): Mean uptime over the last   <code>part_reward_lookback</code> time units.</li> </ul> <p>To implement a custom reward, modify the reward logic in this section or override the step method.</p>"},{"location":"userguide/rl.html#reset","title":"<code>reset()</code>","text":"<p><pre><code>obs, info = env.reset(seed=None, options=None)\n</code></pre> Resets the environment and simulation:</p> <ul> <li>Calls <code>line.reset(random_state=seed)</code> internally to reset randomness. This ensures the environment behaves differently every time.</li> <li>Resets internal counters, like number of produced or scraped parts.</li> <li>Resets all line objects to initial state, i.e., removes all carriers from the production line.</li> <li>If <code>render_mode='human'</code>, sets up drawing and renders the first frame.</li> </ul>"},{"location":"userguide/rl.html#training","title":"Training","text":"<p>LineFlow follows the standard Gym API, so any Gym-compatible RL library will work. For example, with the PPO implementation of <code>stable_baselines3</code>:</p> <pre><code>import stable_baselines3 as sb\n\nmodel = sb.PPO(\n    \"MlpPolicy\",\n    env,\n    learning_rate=3e-4,\n    batch_size=64,\n    verbose=1\n)\nmodel.learn(total_timesteps=200_000)\n</code></pre> <p>Key hyperparameters to tune include learning rate, batch size, and the frequency of policy updates. Because production-line dynamics can exhibit long time constants (ramp ups, buffer transient), it\u2019s often beneficial to train with a curriculum of increasing episode lengths or gradually more challenging line layouts.</p>"},{"location":"userguide/rl.html#debugging","title":"Debugging","text":"<p>To visualize model actions, instanziate the environment with <code>render_mode='human'</code>:</p> <pre><code>env_eval = LineSimulation(\n    line=MyNewLine(),\n    simulation_end=4000, \n    render_mode='human',\n)\n</code></pre> <p>Then, the interaction of a trained <code>model</code> can be visualized as follows:</p> <pre><code>obs, _  = env_eval.reset()\ndone = False\nwhile not done:\n    action = model.predict(obs, deterministic=True)\n    obs, reward, terminated, truncated, info = env_eval.step(action)\n    done = terminated or truncated\nenv_eval.close()\n</code></pre>"},{"location":"userguide/rl.html#evaluation","title":"Evaluation","text":"<p>An online evaluation can be done using materials on board of the training framework. Here is an example how an online evaluation can take place if  using <code>stable_baseline3</code> <code>EvalCallback</code>. Here, a <code>curriculum_callback</code> is triggered which may increases the difficulty of the task (see below):</p> <p><pre><code>eval_callback = EvalCallback(\n    eval_env=env_eval,\n    deterministic=True,\n    n_eval_episodes=1,\n    eval_freq=10, \n    callback_after_eval=curriculum_callback,\n)\n</code></pre> How often the model is evaluated can be controlled over the <code>eval_freq</code> argument, we refer to the official documentation of stable_baselines3 for details. Then, pass the <code>EvalCallback</code> to the training via the callback argument.</p> <pre><code>model.learn(\n    total_timesteps=10_000,\n    callback=eval_callback)\n)\n</code></pre>"},{"location":"userguide/rl.html#monitoring","title":"Monitoring","text":"<p>LineFlow integrates Weights &amp; Biases over the <code>stable_baselines3</code> API for logging of rewards, episode lengths, and custom metrics. You can log additional information using the <code>info</code> parameter of a <code>Line</code> object. The <code>info</code> parameter must be a list of tuple passed as a string. The tuple pairs consist of the line object name and the name of the state you want to track for the given object, for instance:</p> <pre><code>from lineflow.examples import MultiProcess\n\nline = MultiProcess(\n    alternate=False,\n    n_processes=3,\n    info=[('SwitchD', 'index_buffer_out')],\n)\n</code></pre> <p>returns information about the outgoing buffer of <code>SwitchD</code> to the <code>info</code> dict returned by <code>env.step</code>.</p>"},{"location":"userguide/rl.html#curriculum-learning","title":"Curriculum learning","text":"<p>Curriculum learning in reinforcement learning is a training strategy where an agent is exposed to a sequence of tasks that gradually increase in complexity or difficulty. This approach helps the agent to learn simpler tasks first,  building foundational skills that can be transferred to more challenging tasks, improving learning efficiency and performance. It mimics the way humans learn progressively and is particularly useful in environments with sparse rewards or complex dynamics.</p> <p>In LineFlow we provide the <code>CurriculumLearningCallback</code>. Its <code>_on_step</code> method is called every step. The user can use this method to evaluate whether some aspect of the training should be changed. The <code>update_task</code> method calls env_methods that are defined in the <code>LineSimulation</code> environment.</p> <p>Our curriculum learning callback updates the scrap factor when the reward reaches a certain thresh hold over a given look back period.</p> <pre><code>curriculum_callback = CurriculumLearningCallback(\n    threshold=100, \n    update=0.2, \n    look_back=3,\n)\n</code></pre> <p>The curriculum callback can be run in every evaluation via the <code>EvalCallback</code> (see Evaluation).</p>"},{"location":"userguide/rl.html#agent-interaction","title":"Agent Interaction","text":"<p>The following diagram visualizes the class interactions.</p> <pre><code>graph LR\n  Agent --&gt;|interacts with| Environment\n  Environment --&gt;|holds | LineClass\n  LineClass --&gt;|holds | LineState\n  LineState --&gt;|holds | ObjectState\n  ObjectState --&gt;|holds | Substates\n  LineClass --&gt;|holds | LineObjects\n  LineObjects &lt;--&gt;|updates / acts upon| Substates</code></pre>"},{"location":"userguide/visualization.html","title":"Visualization","text":"Sorry, your browser can\u2019t play this video."},{"location":"userguide/visualization.html#drawing-and-controlling-visualization","title":"Drawing and Controlling Visualization","text":"<p>To draw a line and control its visualization in the simulation, you can use the <code>position</code> keyword for objects and the <code>visualize</code>, <code>realtime</code>, and <code>factor</code> keywords for controlling the visualization behavior.</p>"},{"location":"userguide/visualization.html#using-the-position-keyword","title":"Using the <code>position</code> Keyword","text":"<p>The <code>position</code> keyword specifies the coordinates of objects (e.g., <code>Source</code>, <code>Sink</code>, <code>Switch</code>) in the simulation. These coordinates are used to draw the objects on the visualization screen. For example:</p> <p><pre><code>source = Source(\n    name='Source',\n    position=(100, 300),  # X, Y coordinates\n    processing_time=5,\n    ...\n)\n\nsink = Sink(\n    name='Sink_1',\n    position=(500, 200),  # X, Y coordinates\n    processing_time=10,\n    ...\n)\n</code></pre> The <code>position</code> values determine where the objects appear on the screen. You can adjust the coordinates to arrange the layout of your line visually.</p>"},{"location":"userguide/visualization.html#controlling-the-visualization-with-keywords","title":"Controlling the Visualization with Keywords:","text":"<ol> <li> <p><code>visualize</code>:</p> <ul> <li>Set this to <code>True</code> when calling the run method to enable the graphical visualization of the line.</li> <li>Example: <pre><code>line.run(simulation_end=200, agent=agent, visualize=True)\n</code></pre></li> </ul> </li> <li> <p><code>realtime</code>:</p> <ul> <li>Set this to <code>True</code> when initializing the Line object to make the simulation run in real-time. This ensures that the simulation speed matches the wall-clock time.</li> <li>Example: <pre><code>line = MultiSink(realtime=True, n_sinks=5, alternate=False)\n</code></pre></li> </ul> </li> <li> <p><code>factor</code>:</p> <ul> <li>This controls the speed of the visualization when <code>realtime=True</code>. A factor of 1.0 means the simulation runs at normal speed, while a smaller value (e.g., 0.5) slows it down, and a larger value (e.g., 2.0) speeds it up.</li> <li>Example: <pre><code>line = MultiSink(realtime=True, factor=0.5, n_sinks=5, alternate=False)\n</code></pre></li> </ul> </li> </ol>"},{"location":"userguide/visualization.html#example-usage","title":"Example Usage","text":"<p>Here\u2019s how you can combine these keywords to visualize a line: <pre><code>if __name__ == '__main__':\n    line = MultiSink(realtime=True, factor=1.0, n_sinks=3, alternate=True)\n    agent = make_greedy_policy(3)\n    line.run(simulation_end=300, agent=agent, visualize=True)\n</code></pre></p> <p>This will:</p> <ul> <li>Arrange the objects based on their position values.</li> <li>Run the simulation in real-time (<code>realtime=True</code>).</li> <li>Display the visualization (<code>visualize=True</code>) at normal speed (<code>factor=1.0</code>).</li> </ul>"}]}